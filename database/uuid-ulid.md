# UUIDやULID

## 概要

データベース設計において、AutoIncrementな純粋な番号(連番)の他にUUIDやULIDがあるけど、それらの違いと結局どれ使えば良いのかという話。

## 連番の欠点

まず最初に脳死で設計する時に選択肢となる連番の欠点について理解してみる。

- リソースの特定の容易になる
- システム規模(会員数)が推測されやすい

この辺りが挙げられる。セキュリティ面以外においても、競合他社から容易にシステムのことを推測されやすくなり、優位にビジネスを進められてしまうみたいなこともあるかもしれない。

## UUID

UUIDとは何か？特徴を列挙する。

- Universally Unique Identifier
- 128bit
- 複数のバージョンが存在する
  - v4: 全てのビットをランダム値にする（生成が簡単で、一意性が高い）
    - 128ビットのうち、特定の4ビット（バージョンフィールド）を0100に設定する
    - 次に、特定の2ビット（バリアントフィールド）を10に設定する（これにより、UUIDがRFC 4122に準拠していることを示す）
  - v7: v4をソート可能にしたもの
    - 現在のタイムスタンプをミリ秒単位で取得し、48ビットのビット列に変換する
    - 残りの80ビットを暗号学的に安全な乱数で埋める
  
## ULID

続いて、ULIDとは何か？特徴を列挙する。

- Universally Unique Lexicographically Sortable Identifier
- UUIDの欠点を補う形で設計された一意識別子
- 時系列順にソート可能で、データの管理や検索が容易
- UUIDと比べて短く、URLなどで使用する際に便利
- 生成方法
  - タイムスタンプの取得：現在のタイムスタンプをミリ秒単位で取得し、48ビットのビット列に変換
  - 残りの80ビットをランダムな値で埋める
  - 生成されたビット列をCrockford's Base32でエンコード

## UUID v7とULIDの違い

UUID v7とULIDの違いをまとめる。基本的にはULIDの方が優れているように感じる。

- 文字数
  - UUIDv7：ハイフンを含む36字
  - ULID：特殊文字を含まない26文字
- ランダム部
  - UUIDv7：12bit + 62bit
  - ULID：80bit
- 特殊文字の使用
  - UUIDv7：ハイフンを含む
  - ULID：特殊文字を含まない）

## UUIDやULIDの欠点

連番より優れていそうなUUIDやULIDだが、以下のような欠点もある。

- インデックスには不都合があり、クエリパフォーマンスが低下する
- UUID v4はソートができない
- UUID v7とULIDは生成時間が漏洩するリスクがある

## クエリパフォーマンスが低下するについて深堀りする

「インデックスには不都合があり、クエリパフォーマンスが低下する」というだけでは納得できないので、ちょっと深堀りしてみる。

MySQL(InnoDB)の話になるが、主キーのインデックスとしてクラスタインデックスがある。  
これはキーの値を比較した順序が近いほど物理的に近接した場所にレコードのデータが配置されるため、連番の場合は、連続して投入されたデータはディスク上に近い場所にあり、キャッシュの恩恵が受けられる。  
UUID(v4)は、書き込み先がランダムになるので、キャッシュヒットの割合が下がり、パフォーマンスが低下する。

一方、UUID v7やULIDは先頭48bitがタイムスタンプであり、クラスタインデックス上でも投入順に隣接して格納される。

PostgreSQLは、主キーインデックスとは別の領域にレコードデータが保存されるため、このような制約がない。何なら標準でUUID型も用意されている。

## 結論

結論としては、その時のケースによって使い分ければ良いのかなと思う。  
完全な個人的な意見ではあるが、ユーザーに露出するデータはUUID v7 or ULIDにして、それ以外は連番で良いのかなと思った。  
UUID v4はあえて使うシーンはなさそうかなという印象。

## 参考

- [UUIDとULIDを理解していない方は見た方がいい記事](https://zenn.dev/kazu1/articles/e8a668d1d27d6b)
- [UUID - Wikipedia](https://ja.wikipedia.org/wiki/UUID)