# インデックス

※MySQLのInnoDBでの話

- 主キーで自動的にクラスタ化インデックスを作成される
  - B+treeそのものがテーブル本体（なので1つのテーブルに1つしか設定できない）
  - このインデックスの順番で、ディスク上の物理的なデータが並んでいる
- CREATE INDEXを使って作成したものは非クラスタ化インデックスが作成される
  - ここにはインデックスが貼られているカラムとクラスタ化インデックスへの参照が含まれる
  - なので非クラスタ化インデックスで検索を行うと、見つかった参照(ポインタ)で主キー(クラスタ化インデックス)を引き直すKey Lookupが発生する
    - このKey Lookupが大量に発生するとI/Oが嵩むと「インデックス貼っているのに遅い」ということが発生する
      - そこで必要カラムをインデックスに含めるカバリングインデックス（複合インデックス）を作成することで、データ本体を見に行かなくても、葉ノードに含まれるデータのコピーを見るだけで済むので、Key Lookupが発生しない

## インデックス(B+tree)を使用した検索の内部動作

- Index Seek: ルートからリーフへ（垂直方向への移動）
  - ルートノードを読み込む
    - 通常頻繁にアクセスされるのでバッファプール（メモリキャッシュ）に載っている
  - 中間ノードの読み込み
    - 中間ノードとは、詳細なエリアを指す案内板のようなもので、ルートとリーフの間に存在する
    - ルートはもちろんこの中間ノードにも実際のデータは含まれておらず、ある範囲への参照（例：20〜29際はポインタA）のみが含まれていて、分岐を責務とし、リーフノードへの道のりを示す役割を担う
  - リーフノードへの到達
    - 実際のデータ（もしくはそのポインタ）が書かれている最下層のリーフノードに到達する
    - ここでのリーフノードは「ページ」
- 水平方向の検索（ページ内での特定）
  - ページ内は、通常キー順に並んでいるので、その中で二分探索が行われる
  - ここで該当レコードのポインタが特定される
- Lookup（データ本体へのアクセス）
  - ここでカバリングインデックスか否かで動きが変わる
    - A.インデックスだけで完結する場合（カバリングインデックス）
      - リーフノードの中にSELECTで要求されたカラムが含まれているのでここで探索終了となる
    - B.データ本体を見にいく必要がある場合（Key Lookup）
      - 特定した主キーを持って、データ本体（クラスタ化インデックス）のB+treeをもう一度ルートから検索し直し、ようやくページに辿り着きそこから全カラムを読み取る

### カーディナリティと選択率

- カーディナリティ：値の種類の多さ
  - 例えば性別などの値の種類が少ないデータであれば、リーフノードに同じ値が大量に並ぶ
- 選択率：その条件で検索した時に、全体の何%のレコードがヒットするかの割合
- これらが悪い（低い）と、インデックスを使用してリーフノードに辿り着いても、大量にデータがあるリーフノードを左から走査する必要が発生したり、KeyLookup（データ本体を取りに行くのにクラスタ化インデックスのB+treeをもう一度ルートから検索し直す）が大量に発生したりする
- カーディナリティと選択率が悪い（低い）カラムに対しての対策
  - インデックスを貼らない
    - 全件走査の方がマシというケース
    - 全件走査であれば、シーケンシャル（連続）アクセスとなり、ディスクのヘッドを動かさずに一度に大量のページをメモリへロードできる
  - 複合インデックスを貼る
    - カーディナリティと選択率が高いカラムとの複合インデックスにする
    - そうすると、2つのカラムのセットで1つのキーとしてソートされて並ぶ
    - 

## インデックスの再構築

## インデックスのライフサイクル

## インデックスを貼っているのに遅い問題への解決アプローチ

- そもそも検索時にインデックスが使用されていない
  - インデックス列への加工演算
    - B+treeには生の値でソートされているので、`WHERE YEAR(created_at) = 2023`のような書き方で加工してしまうと、木を辿ってもわからないため
  - 後方一致・中間一致のLIKE検索
    - B+treeは左側（前方）から順に並んでいるため（例えば「太郎」で終わるデータを探そうとすると、リーフノードを端から端まで見る必要がある）
  - 暗黙の型変換
    - 内部的に関数が適用されたのと同じ状態になり、木が使えなくなる
- インデックスは使用されているが遅い
  - フルインデックススキャン
    - リーフノードを端から端まで全部横に歩いている状態
  - IndexSeek後の大量のKeyLookup
    - 木を垂直に降りて特定の範囲を見つけるところまで速いが、そこから本体への引き直しが多くなる事象
      - 「選択率が低い」と、例えば100万件のうち50万件にヒットし、50万件分本体データ（別のディスク領域）へランダムアクセスが発生している状態
  - 複合インデックスの順番ミス
    - age,nameという複合インデックスがあるのに、nameカラムのみで検索するとインデックスが効かない
    - これは、ageという第一条件で枝分かれしているため、nameのみでの検索ではリーフノードに辿り着けない
      - 電話帳で、「太郎」という名前の人を探すのと同じイメージ
