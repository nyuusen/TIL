# インデックス

※MySQLのInnoDBでの話

- 主キーで自動的にクラスタ化インデックスを作成される
  - B+treeそのものがテーブル本体（なので1つのテーブルに1つしか設定できない）
  - このインデックスの順番で、ディスク上の物理的なデータが並んでいる
- CREATE INDEXを使って作成したものは非クラスタ化インデックスが作成される
  - ここにはインデックスが貼られているカラムとクラスタ化インデックスへの参照が含まれる
  - なので非クラスタ化インデックスで検索を行うと、見つかった参照(ポインタ)で主キー(クラスタ化インデックス)を引き直すKey Lookupが発生する
    - このKey Lookupが大量に発生するとI/Oが嵩むと「インデックス貼っているのに遅い」ということが発生する
      - そこで必要カラムをインデックスに含めるカバリングインデックス（複合インデックス）を作成することで、データ本体を見に行かなくても、葉ノードに含まれるデータのコピーを見るだけで済むので、Key Lookupが発生しない

## インデックス(B+tree)を使用した検索の内部動作

- Index Seek: ルートからリーフへ（垂直方向への移動）
  - ルートノードを読み込む
    - 通常頻繁にアクセスされるのでバッファプール（メモリキャッシュ）に載っている
  - 中間ノードの読み込み
  - リーフノードへの到達
    - 実際のデータ（もしくはそのポインタ）が書かれている最下層のリーフノードに到達する
    - ここでのリーフノードは「ページ」
- 水平方向の検索（ページ内での特定）
  - ページ内は、通常キー順に並んでいるので、その中で二分探索が行われる
  - ここで該当レコードのポインタが特定される
- Lookup（データ本体へのアクセス）
  - ここでカバリングインデックスか否かで動きが変わる
    - A.インデックスだけで完結する場合（カバリングインデックス）
      - リーフノードの中にSELECTで要求されたカラムが含まれているのでここで探索終了となる
    - B.データ本体を見にいく必要がある場合（Key Lookup）
      - 特定した主キーを持って、データ本体（クラスタ化インデックス）のB+treeをもう一度ルートから検索し直し、ようやくページに辿り着きそこから全カラムを読み取る

## 

## インデックスの再構築

## インデックスのライフサイクル
