# ハッシュ化・ソルト・ペッパー

## ハッシュ化とは？

- 元のデータから、一定の規則で変換し、固定長の値を算出すること
- 例: `password`をSHA-256ハッシュ化すると`5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8`という文字列

## ハッシュ化アルゴリズム

- MD5
  - 128ビット（32文字）のハッシュ値
  - 処理が速いが、衝突（同じハッシュ値になる異なる入力）が見つかっており、セキュリティ用途には非推奨
- SHA-1
  - 160ビット（40文字）のハッシュ値
  - MD5より安全だが、衝突が発見されており、現在は非推奨
- SHA-256（SHA-2系）
  - 256ビット（64文字）のハッシュ値
  - 現在主流の安全なアルゴリズム。パスワードやデータの整合性確認に広く使われる
- SHA-512（SHA-2系）
  - 512ビット（128文字）のハッシュ値
  - SHA-256よりさらに長く、安全性が高い

## ハッシュ化だけではセキュリティリスクが高い理由

- 単なるハッシュ値が漏洩した場合、攻撃者側でよく使われるパスワードとそのハッシュ値を事前計算してテーブル化しておいたものと照合するレインボーテーブル攻撃のリスクが高いため

## ソルト

- 由来は、ソルト（塩）で、ひとつまみ加えることで元の値（味）を変化させるという意味
- レコード毎にランダム値（乱数）を生成し、パスワード＋ソルトをハッシュ化することでセキュリティ性を向上させる
- この際、ソルトは同一レコードの値として保存することが多い
- 同一レコードだと漏洩した時に危険なのでは？
  - 漏洩した場合、1レコードに含まれるのはハッシュ値(パスワード+ソルトをハッシュ化したもの)とソルト値
  - 攻撃者が保持しているのは、大抵ソルトなしのパスワードハッシュなので、ソルトありのハッシュ値一覧は当然保持していない
  - テーブル化するには再度計算が必要になるので、漏洩後にパスワードが盗用されるまでの時間を稼ぐことができる
- 詳しい解説がされている徳丸さんの記事: [ソルト付きハッシュのソルトはどこに保存するのが一般的か #Security - Qiita](https://qiita.com/ockeghem/items/d7324d383fb7c104af58)

## ペッパー

- ソルトに加えて、さらに隠し味（胡椒）
- こちらはレコード毎ではなく全てのレコードで1つの固定値をパスワードに付加する
- ペッパーは、SecretsManagerなどの秘匿情報を保持する専用の箱か、それをECSタスクの環境変数としてSecretsManagerから取得するようにする形が良さそう
  - 前者の方がセキュリティ性は高いけど、ハッシュ化のたびにSecretsManagerへのリクエストが発生するので、費用面とパフォーマンス面でデメリットあり

## まとめ

- ハッシュ化のみではセキュリティ的に不安がある
- せめてハッシュ化＋ソルト対応は行おう
- コストやパフォーマンス面で許容されるなら、ハッシュ化＋ソルト＋ペッパー対応が最も安全

## (余談)タイミング攻撃

- ハッシュ値をプログラムで比較する際、内部で1文字(1バイトずつ)順番に行われることが多い
- 先頭から比較していき、比較途中で不一致があれば、そこで処理終了となる（残りのバイトは比較されない）
- この作りを逆手にとり攻撃をするのが「タイミング攻撃」であり、
  - 攻撃者は入力値を少しずつ変えながら、比較処理の時間を測定する
  - 比較時間が長くなった場合、「先頭のバイトが一致している」と推測できる
  - この方法を繰り返すことで、正しいハッシュ値（＝パスワード）を特定できる
- 対策としては、比較処理は決まった時間で返すようにする
  - Goでは、`subtle.ConstantTimeCompare`がある
