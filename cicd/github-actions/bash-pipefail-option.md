# Bashのpipefailオプションについて

## はじめに

GHAでGitHubHostedRunner上でUbuntuを動かす場合、デフォルトのシェルはbashとなる。
ただ厄介なことにshellキーの有無で、bash起動オプションが異なるという挙動があり、その点を深掘ってみる。

なおshellキーの有というのは、`shell: bash`というのをステップで宣言することを指している。

## 具体的なGHAでの起動オプションの違い

- 省略時: `bash -e {0}`
- 記述時: `bash --noprofile --norc -eo pipefail`

※起動オプションでなくても、`set -e`等でスクリプトの中で実行することも可能

### オプションを理解する

- `-e`: スクリプト内のどこかでコマンドが失敗すると即時終了する
- `-o pipefail`: パイプラインの中で失敗したコマンドをエラーとして扱う
- `--noprofile --norc`: .bash_profile や .bashrc を読み込まずに起動する（環境の違いを排除）

## パイプラインとは？

- コマンドの出力を次のコマンドの入力として渡す構文のこと
  - `cat example.txt | grep "keyword"`
- pipefailがないデフォルトの状態では、パイプラインの最終コマンドの終了ステータスのみが評価されるので、途中のコマンドが失敗してもスルーされる可能性がある
- `-o pipefail`の設定をすることで、パイプラインのどこかが1つでも失敗すれば、全体が失敗と評価される
- スクリプトの中で、`set -o pipefail`とやることでも設定可能

## なぜデフォルトではpipefailがないのか？

- pipefailは比較的新しいオプションであり、、後方互換性のためデフォルトでは無効になっている
  - Unixの思想として「小さいコマンドを繋いで処理を作る」というのがあり、パイプで繋いで小さい処理をインタラクティブに繋ぎ合わせる
- そもそもユーザー入力値を前提に処理を進める場合はpipefailが無効の方が便利だったりする
  - grepして結果無いたびにエラーになるより、エラーなしで処理が継続できた方が柔軟性が高い

## pipefail以外でシェルを堅牢にするオプション

- `-e`(errexit): コマンドが失敗したら即スクリプトを終了
- `-u`(nounset): 未定義の変数を使ったらエラーにする
