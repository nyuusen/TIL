# SQS設計

## SQSの構成要素

- パブリッシャー --- SQS --- コンシューマー(ワーカー)

## キューの種類

- 標準
  - 高スループット、順序保証なし、少なくとも1回の配信（重複あり）
- FIFO
  - 順序保証（メッセージグループ単位）、重複排除
  - 注文・決済処理など
- 多くのケースでは標準で良いはず
  - ただし同じメッセージに対して複数処理が走っても結果が同じになる「冪等性」を担保すること

## SQS自体の設定

- 可視性タイムアウト
  - メッセージを取得した後、指定時間は他のコンシューマからは見えなくなる設定
  - 長すぎると遅延、短すぎると再処理されてしまうリスクがある
- デッドレターキュー
  - 処理失敗したメッセージを隔離して格納するキュー
  - エラーハンドリングや再試行の仕組みが必要なら必須

## SQS vs SNS + SQS

- 単一SQSかSNS＋SQS構成

### SQS Only

- シンプルな設計

### SNS＋SQS構成

- 前段にSNSを配置することで、複数のSQSにメッセージを通知できる（ファンアウト構成）
- 通知先を増やしたい場合は、SQSを新しく作り、SNSの通知先を登録するだけで良い（アプリケーション改修不要）
  - 当初はメール通知だけでも良いけど、その後プッシュ通知も送りたいとかなる可能性がある

## コンシューマー設計

- 大前提としてシンプルに作れるのはLambda
- 長時間実行、メモリをたくさん使うような処理なのであればECSやEC2が次点の選択肢となる
- 判断軸
  - 処理時間: Lambdaは最長15分
  - メモリ: Lambdaは10GBまで
  - デプロイ:
    - イベントソース型Lambdaであれば暗黙的にポーリング・メッセージ受信をやってくれるので気にしなくて良い
    - 代わりにECSなどを使用する場合はデプロイ機構を検討する必要がある（常時起動 or 定期実行）
  - オートスケーリング:
    - Lambdaだと考慮不要
    - 自前するケースだと、メッセージ数に応じてスケーリング設定をしたりする必要がある
- EventBridge Pipesを使うという選択肢
  - ワーカーがLambda以外の場合で良いかも？
  - SQSとECSの間に置き、中間処理を任せる
  - ポーリング自動、フィルタ・変換等を行なってくれる
    - アプリケーションロジックにこれらの処理を書かなくて良くなる

## 参考

- [Amazon SQSワーカーのアーキテクチャーをLambdaイベントソース/EventBridge Pipes/独自の3パターンで比較してみた | DevelopersIO](https://dev.classmethod.jp/articles/sqs-consumer-pattern/)
