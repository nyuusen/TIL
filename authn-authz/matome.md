# 認証認可まとめ

## はじめに

認証認可についての知識が散らかりがちなので調べたことをメモ（随時更新）

MDNに良い感じにまとめてあった。
[HTTP 認証 - HTTP | MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Authentication)

## 認証認可を実現する技術と仕様

- ID/パスワード
- SAML
- OAuth
- OpenID Connect
- JWT
- MFA

### Basic認証

- usernameとpasswordをBase64エンコードしてHTTPヘッダのAuthorizationに設定する
  - リクエストのたびにパスワードを送信する形
- 実装が簡単（ヘッダの値をセット・検証するだけ）
- しかし盗聴されるとBase64デコードすることで元の値が見れてしまうのでセキュリティ性は低くない
- Basic認証を採用する場合はHTTPS化することが推奨される

### ダイジェスト認証

- Basic認証の改良版
- サーバが生成したランダムの文字列をパスワードに付与し、IDとパスワードをMD5でハッシュ化して送信
  - これもリクエストのたびにパスワードを送信する形
- サーバ側でも登録済みの認証情報をハッシュ化し、照合することで認証する

### セッションベース認証

- リクエストの度にパスワード等を送る(Basic/ダイジェスト認証)のは良くないので、サーバー側でログイン済み情報を保持する「セッション」という仕組みが誕生
- セッションは、このユーザーはこのセッションという情報を保持しているので「ステートフル」と言える（サーバーが状態を持っている）
  - サーバー側で強制ログアウトや履歴管理が可能
- クライアント側では、セッションID的なものをCookieで保持することが多い
  - Cookieで保持することが多い理由
    - クライアント側はセッションIDだけを知っていれば良い
    - セッションIDをCookieに保存しておけば、ブラウザが自動で送信してくれる（フロントエンドがセッションの存在を意識しなくて良い）

### JWT認証

- JSON Web Tokeの略で、クライアントとサーバー間で認証等の情報を安全にやりとりするための標準規格
- JWTには、ヘッダー（トークン種類や署名アルゴリズム）とペイロード（ユーザーID、有効期限、ロール等）と署名（ヘッダとペイロードを暗号鍵で署名し、改竄されていないことを保証する）
- JWTはトークンに全ての情報（ユーザーIDや期限など）を持っているので「ステートレス」な認証と言える
- サーバーは、クライアントから送られてきたトークンを検証するだけなので、DBやセッションを見に行く必要はない
  - その代わり、サーバ側で保持していない＝一度発行したトークンをサーバ側で無効化するみたいなことはできない
- JWTは、LocalStorageで保持することが多い
  - LocalStorageで保持することが多い理由
    - JWTは、Authorizationヘッダにセットする（自動送信されるCookieとは異なり、リクエストごとにセットする必要がある）
    - つまり、ブラウザで保持しているトークンを何かしらの形で、リクエストに含める必要がある
    - そうなると、JSからアクセスできる場所が都合良いので、LocalStorageに保存することが多い（CookieにHttpOnly属性が付与されているとJSから読み取れないため）
    - 結果、SPAやCSR前提のアプリケーションで採用されるケースが多い
- JSからアクセスできるということはXSSのリスクがある（CookieはHttpOnly属性を防げる）
  - LocalStorageにあるトークンを盗まれてしまうリスクがある

### セッション vs JWT

- サーバーとクライアント結合度合い
  - Cookieは、ブラウザ前提とした設計になりがち
  - Authorizationヘッダでトークン送る形式(JWT)は、ブラウザ以外（例：モバイルアプリ）でも使用できる
  - つまり、Cookieを使用するとサーバーとクライアント(種類)の依存度が強まってしまう
- CORS制御の面倒度合い
  - APIとフロントが別ドメインである場合、CORS設定が面倒（Cookie送るのにcredentials: 'include'が必要、SameSite設定）
  - 
- スケーリング
  - セッションは、サーバー側で保持されるのでスケーリングに不向き
  - ただし昨今はデータストアに置くケースが多いのであまり考えなくて良いかも
- クライアント側での考慮
  - セッションはCookieにさえセットされていれば自動で送信されるのでクライアント側での考慮が必要ない
  - また、CookieはSSRやHTMLフォームとの相性が良い
    - SSRで初回リクエストした時、Cookieなら自動で送信されるため
- クライアント側でのログイン状態管理
  - SPAなどではログイン状態をクライアント側で保持・制御するケースが多く、JWTの方が向いている
- マイクロサービス
  - サーバーが異なっていても送りやすいJWTが向いている

#### 結論

アプリケーションの作り方でどちらを採用するかを決めるのが良いか？（私見）

- SSR前提のアプリケーション：セッション
  - SSR初回リクエスト/HTMLフォーム送信時にCookieに送ってくれるのは大きい
- SPA：トークンベース（JWT）
- ハイブリッド構成(SSR/CSR)：セッション

## サーバー側で認証認可に関連する情報を保持する方法

- セッション
  - データベースやRedisなどの外部ストレージに保存する

## クライアント側で認証認可に関連する情報を保持する方法

- LocalStorage
  - 実装は楽(setItemとかremoveItemなどのAPIを実行するだけ)
  - 一方、JavaScriptを使用するのでXSSで盗まれる可能性がある
- Cookie
  - HTTP Onlyを属性を付加することでJavaScriptからの操作を無効にできる
- インメモリ
  - JavaScriptでブラウザのメモリ内に保存する(クロージャに入れるとかするイメージ)
  - リロードするとログアウト状態になる、タブ間でログイン状態が共有されないなどの問題がある
- Auth0
  - Silent Authenticationという仕組みがある
    - インメモリ形式で実装しているが、リロード時にログアウトしてしまう問題がないのが利点
    - 実際の仕組みとしては、HTMLのiframeタグを駆使している
  - 認証基盤のロックインや一定規模が超えた場合に課金が発生するという課題はある
- 参考
  - [認証用トークン保存先の第4選択肢としての「Auth0」 | ログミーBusiness](https://logmi.jp/main/technology/324349)

- 読みたい記事や見たい動画
  - [SPAセキュリティ入門～PHP Conference Japan 2021 | ドクセル](https://www.docswell.com/s/ockeghem/ZM6VNK-phpconf2021-spa-security)
  - [Cookieにまつわるセキュリティ - YouTube](https://www.youtube.com/playlist?list=PLWiFLcGkQgLx8lbno3zZEinqu5C19hwET)

## 認証技術

### 

## 参考

- [HTTP 認証 - HTTP | MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Authentication)
