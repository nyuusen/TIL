# Node.js

## はじめに

Node.jsでサーバーサイドの開発って結局微妙なのでは？複雑性増すよね？というようなトピックでXが盛り上がっていた。

雰囲気でしか掴めていなかったので、改めてNode.jsとは何者なのか？他と比較した時の優位性は何なのか？をちょっと調べてみた。

## そもそもNode.jsとは？

- ブラウザ外でJavaScriptを動かす実行環境
- シングルスレッドで動作する
- Node.jsはいくつかのモジュールが組み合わされて構成されている
  - そのうち理解する上で大事なのが「V8」と「Libuv」 

## V8とは？

- V8は、Googleが開発するJavaScriptエンジン
  - つまり、JavaScriptで書かれたソースコードを受け取り、機械語に変換してOS上で実行してくれるやつ
- chromeとNode.jsはJavaScriptエンジンとしてV8を採用している。

## Libuvとは？

- OSによるディスクへの書き込みや通信などの処理に関するイベントを監視し、そのステータスをNode.jsに通知する機能を持つ
 - イベント監視はOSによって仕様や実現方法が異なるが、この辺りを抽象化し、OSを気にすることなく使えるようにしているのがLibuvである

[I/Oのイベント管理がキモ | 日経クロステック（xTECH）](https://xtech.nikkei.com/it/article/COLUMN/20120725/411442/)
→分かりやすい図あり<br>
[Node.jsを理解する (libuv)](https://zenn.dev/mmomm/articles/ff83eb49a7b642)

## Node.jsの特徴

### 非同期I/O

- I/Oとは、Input/Outputのことでファイルの読み書き/ネットワーク通信/データベースアクセスなど、プログラム外とのやりとりする処理全般を指す
- 非同期I/Oとは、リソースを効率的に利用するための手法
- 具体的には、時間のかかるI/O操作の完了を待たずに次の処理を進められるので、大量の同時接続を効率的に処理することができる

[memo]<br>
なぜ非同期I/Oを採用しているかというと、Node.jsはシングルスレッドで動作するという背景があるらしい。<br>
マルチスレッドの場合は複数のスレッドに分散して処理を実行できるが、シングルスレッドの場合は文字の通りそれができない。<br>
なので、時間軸で分散させる目的で、非同期I/Oを採用している。

### イベント駆動モデル

- イベントが発生するたびに対応するコールバック関数が呼び出される仕組みのこと
- 具体的には、以下のように動作する
  - イベント登録：非同期操作(I/O操作)が発生すると、その操作に対するコールバックがイベントキューに登録される
  - イベント処理: イベントループがイベントキューを監視し、キューに入ると対応するコールバックを実行する
- これにより、Node.jsはシングルスレッドでありながら、並行処理を効率的に行うことができる

## Node.jsの優位性

### C10K問題の解決

- C10K問題とは「同時に10,000（K=1000）クライアントを処理する際に効率的に処理できない」という問題のこと
- 従来のサーバー設計は、1接続ごとに1つのスレッドとプロセスを割り当てることが一般的だった
  - この方法では、スレッドやプロセスのオーバーヘッドが大きくなり、メモリ消費やコンテキストスイッチの負荷が高くなるので、10000以上の同時接続を効率的に処理するのは難しいよねという意味
- この問題に対し、Node.jsは面で優位性がある
  - 1つのスレッドで多くのI/O操作や非ブロッキングで処理できるため、少ないリソースで多数の同時接続を捌くことができる
  - 従来のスレッド/プロセスベースのアプローチと異なり、Node.jsは各接続にスレッドやプロセスを割り当てるのではなく、イベントループを利用してI/O操作の完了を待ち受けるため、メモリ使用量が低く抑えられ、コンテキストスイッチのオーバーヘッドがない

### ロングポーリングの効率的な処理

- ロングポーリングとは、HTTPのみで擬似的にプッシュ通信(サーバー→クライアントへの通信)を実現する手法の1つ。
-   具体的には、クライアントがサーバーにHTTPリクエストを送信し、サーバーは応答せず受付のみし、保留のまま接続を維持しておき、サーバー側が任意のタイミングで保留を解除して応答する。応答を受け取ったクライアント側はすぐさま同じくサーバーにHTTPリクエストを送信し、これを繰り返すことでリアルタイム通信を実現することができる。
- Node.jsは非同期I/Oとイベント駆動モデルを採用しているため、ロングポーリングのような多くのオープンな接続を効率的に処理するのに適している
  - 非同期I/O: リクエストを非ブロッキングで処理するため、I/O操作の完了を待たずに次の操作を開始できるため、リソースの効率的な使用が可能である
  - イベント駆動モデル: リクエストが来るたびにNode.jsはイベントキューに追加し、非同期に処理できるため、同時に多数のリクエストを効率的に処理できる
 
## その他

冒頭で書いた「複雑性増すよね？」という意見が指すのは恐らくモジュール解決についてのことがほとんどだと思う。

モジュールについては[Node.js + TypeScriptのモジュールを整理してみる](https://blog.koh.dev/2024-04-23-nodejs-typescript-module/)がとてもわかりやすかった。


