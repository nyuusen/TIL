# 作りながら学ぶWebシステムの教科書

## 概要

[作りながら学ぶWebシステムの教科書](https://info.nikkeibp.co.jp/media/LIN/atcl/books/081600038/)の読書メモ。気づきや調べたことをまとめていく。

## Chapter2 Webシステムの基本、HTTP／HTTPSプロトコルを理解する

- HTTP/1.1はテキストベースプロトコル(ASCII文字), HTTP/2はバイナリベースプロトコル
  - それ以外にも1つのTCP接続で複数のリクエスト/レスポンスをやり取りできるようになったり、
  - ヘッダの圧縮等がより、高速で効率的な通信を実現できるようになった
  - [そろそろ知っておきたいHTTP/2の話 #http2 - Qiita](https://qiita.com/mogamin3/items/7698ee3336c70a482843#1%E3%81%A4%E3%81%AEtcp%E6%8E%A5%E7%B6%9A)
- HTTP/3で特徴的なのはQUICと呼ばれるUDPベースの伝送制御上でHTTP通信を行い、高効率や通信を実現している
  - 現在ALBではHTTP/3に対応しておらず、 HTTP/3に対応するにはCloudFrontを経由させる必要がある(?)
- Webサーバー側の設定により、HTTPの使用可能なバージョンが定められている
  - 異なるバージョンでHTTPリクエストを送るとリダイレクトされたり、エラーが返されたりする
  - 普段ブラウザでWebページにアクセスする時はHTTPのバージョンを意識することがない理由はブラウザがよしなにやってくれている
    - 具体的には、ブラウザはデフォルトで多くのサーバーからサポートしているHTTP1.1を使用し、接続を確立する

## Chapter3 Linux

- Linuxディストリビューション
  - OSコアのLinuxカーネルに、UIを構成するデスクトップ環境やコマンド等のユーザーランドソフトウェアを組み合わせてコンピューターにインストールできるようにパッケージングされたもののこと
  - サーバー向けのものも含め、現在は250種類以上も存在する
    - 代表的なのがRedHat系とDebian系
    - RedHat自体は有償サポートがあるため、官公庁や比較的大きめの企業(お堅い金融機関等)で採用される傾向
      - RedHatのソースコードを元にしたCentOSもかつては高いシェアを占めていたが、2021年の開発体制変更を境に多くはUbuntu Serverに移行した
    - Debian系で有名なのがUbuntuであり、現在人気がある
- シェルスクリプト
  - コマンド結果をファイル出力: コマンド > ファイル
  - コマンド結果をファイルに追記: コマンド >> ファイル
  - コマンド結果を次の標準入力に使用: コマンド1 | コマンド2
  - コマンドを続けて実行: コマンド1 ; コマンド2

## Chapter4 仮想化

- LXD: システムコンテナマネージャー
  - Dockerがアプリケーション指向であるのに対し、LXDはシステム指向
  - よりVMに近い動きをする
  - サービス管理システムのsystemdに対応しているため、複数のプロセスやサービスを1コンテナで実行可能
    - Dockerとは異なり、1つのコンテナでWebサーバーとDBサーバー等の複数のサービスを起動することができる
- コンテナ技術とLinuxのかかわり
  - コンテナ型仮想化技術のように、ハイパーバイザーを使用しない仮想化プラットフォームの多くが、LinuxをホストOSとしている
  - これにはLinuxはマルチユーザーOSであるがために、他のプロセスやリソースを厳密に管理する必要があったという背景がある
  - Linuxカーネル機能の名前空間によって、ホストのリソースからコンテナのリソースを隔離して、安全にプロセスを実行できるようになっている
    - 具体的には、名前空間がコンテナAでプロセス(PID:1)とコンテナBでプロセス(PID:1)というのを可能にしている
- つまりまとめると、LinuxはマルチユーザーOSであること故に、1OSの中で複数のリソースやプロセスを管理したいという要求があり、カーネルの名前空間を良い感じに使用し、仮想化技術を実現している

## Chapter6 HTTPS

- SSL/TLSは、インターネット上の通信を暗号化するプロトコル
- SSLを新しい企画として再設計されたのがTLS
  - ただしSSLが歴史的に長く使われている＋広く認知されているため、現在でもSSLとだけ表記されることがある
  - 最新はTLS1.3
- SSL/TLSの暗号化方式
  - 共通鍵暗号方式と公開鍵暗号方式を同時に使用する
- HTTPS通信の流れ（技術詳細）
  - 登場人物と役割
    - **認証局（CA: Certificate Authority）**
      - 信頼された第三者機関。サーバーの公開鍵が本物であることを証明し、証明書にデジタル署名を行う。
      - CAはその証明書を発行する際に、RSAやECDSAなどのアルゴリズムを使ってサーバーの公開鍵やその他の情報にデジタル署名を施す。

    - **サーバー証明書**
      - サーバーの公開鍵、ドメイン名、証明書の有効期限、およびCAのデジタル署名が含まれた証明書。通常はX.509フォーマットで表現される。
      - 証明書には「Subject Public Key Info」というフィールドがあり、サーバーの公開鍵が格納されている。
      - CAが発行した証明書であり、サーバーが信頼できることをクライアントに証明するために使用される。

    - **サーバー**
      - 自身の**秘密鍵**を安全に管理し、**公開鍵**を提供する。
      - クライアントからの要求に対し、X.509フォーマットで表現されたサーバー証明書を送信する。
      - クライアントから送信された共通鍵を秘密鍵を使って復号し、暗号化通信を確立する。

    - **クライアント（ブラウザなど）**
      - サーバーに対してHTTPS接続を要求し、サーバー証明書を受け取る。
      - サーバー証明書のデジタル署名を、CAの公開鍵を使って検証し、証明書が改ざんされていないか確認する。
      - 証明書から公開鍵を取り出し、一時的な**共通鍵**を生成してサーバーの公開鍵で暗号化する。
      - 共通鍵をサーバーに送信し、安全な通信を確立する。
  - HTTPS通信の時系列
    1. **クライアントがサーバーに接続要求を送信**
       - クライアント（例：ブラウザ）は、HTTPSリクエストを送信し、サーバーに接続要求を行う。
       - このとき、クライアントはサーバーにSSL/TLSハンドシェイクを開始します。

    2. **サーバーがサーバー証明書を送信**
       - サーバーは自身のサーバー証明書（X.509形式）をクライアントに送信する。
       - サーバー証明書には、サーバーの公開鍵、ドメイン名、有効期限、認証局（CA）の署名が含まれている。

    3. **クライアントが証明書を検証**
       - クライアントは、証明書に含まれる署名をCAの公開鍵で検証する。ここでは次のステップが行われる：
         1. **証明書の署名検証**：
            - 証明書に含まれているデータを使ってハッシュ値を再計算する。
            - 証明書に付与されたデジタル署名をCAの公開鍵を使って復号し、署名から得られたハッシュ値と再計算されたハッシュ値を比較する。
            - 一致すれば、署名が正当であり、証明書が改ざんされていないと判断される。
         2. **証明書の有効期限確認**：
            - 証明書の有効期限を確認し、現在の日付がその範囲内かを確認する。
         3. **ドメイン名の一致確認**：
            - 証明書に含まれるドメイン名が、クライアントがアクセスしているドメインと一致するかを確認する。
         4. **証明書の失効確認**：
            - クライアントはCRL（証明書失効リスト）またはOCSP（Online Certificate Status Protocol）を使って、証明書が失効していないか確認する。

    4. **クライアントが共通鍵を生成し、サーバーに送信**
       - クライアントは一時的な共通鍵（対称鍵暗号方式で使用される鍵）を生成する。共通鍵は通常AESなどの対称鍵アルゴリズムで利用される。
       - 生成した共通鍵をサーバーの公開鍵で暗号化し、サーバーに送信する。このプロセスにより、共通鍵はサーバーの秘密鍵を持つサーバーだけが復号できる。

    5. **サーバーが共通鍵を復号**
       - サーバーは秘密鍵を使ってクライアントから送信された共通鍵を復号する。
       - 復号に成功した時点で、クライアントとサーバーは共通鍵を共有し、以降の通信はこの共通鍵を使って暗号化される。

    6. **暗号化された通信の開始**
       - これで、クライアントとサーバーの間に安全な通信チャネルが確立され、以降のデータは共通鍵を使って暗号化されて送受信される。
       - 暗号化方式にはAESなどの対称鍵暗号方式が使われ、これにより通信内容が第三者に漏洩するリスクが低減される。

### サーバー証明書

- サーバー証明書は通信の暗号化/なりすまし防止/改ざん防止の役割を担う
  - 通信データを暗号化する鍵としての役割だけでなく、Webサイトを運営する個人や企業が実際に存在するという実在性の証明するのにも使用される
- 実在性の証明
  - サーバー証明書を入手する時に、運営者の住所や連絡先（企業なら法人登記簿）を認証局に提出する必要がある
- サーバー証明書の取得
  - サーバー証明書は、認証局（CA）と呼ばれる第三者機関により発行される
  - Webブラウザには、認証局の正当性を証明するルート証明書が組み込まれていて、正規の認証局によって発行されたサーバー証明書なら、ルート証明書で正当性を確認できる
    - プライベートな認証局を立ち上げて、自前でサーバー証明書を発行することもできる
    - Webブラウザにプライベートな認証局の証明書をインポートすることで、信頼されたルート証明機関として偽装できる

#### サーバー証明書の発行と署名からクライアントによる検証までの流れを整理する

- 証明書発行までの流れ
  - (サーバー)
    - 秘密鍵の作成
    - CSRの作成
      - 秘密鍵を元に作成した公開鍵
      - ドメイン情報
      - 所有者情報(会社情報等)
    - CSRの送付(toCA)
  - (CA)
    - CSRの検証
      - ドメインの所有者が本当か？の確認
      - 所有者自体が正しく存在するか？の確認
      - 公開鍵で復号
    - 証明書の発行
      - CA側でも秘密鍵を作成し、それを用いて署名する
        - 署名＝秘密鍵を用いたハッシュ計算
      - サーバーに証明書を送付
    - 補足:証明書の仕組み
      - X.509という公開鍵インフラストラクチャの証明書形式の標準規格(フォーマット)
      - CA側の公開鍵・所有者の識別情報・CAの署名・シリアル番号・有効期限等の情報が含まれている
  - (サーバー)
    - 証明書をサーバーにインストール
- 証明書の検証
  - (クライアント)
    - サーバーにリクエスト
    - TLSハンドシェイクを開始
  - (サーバー)
    - クライアントに証明書を送付
  - (クライアント)
    - 自身のシステム(OSやブラウザ)に信頼できるルート証明書として登録されているかを確認
    - 証明書に含まれるCAの署名を検証(CAによって正しく発行された証明書かどうかを確認するため)
      - CAの公開鍵を使って解読可能かを確認
      - 解読結果がサーバー証明書と一致するかを確認
        - 復号して得たハッシュ値とクライアント側で計算したハッシュ値が同じであるかを確認するという意味
    - 証明書の内容を検証
      - 証明書に記載されたドメインとアクセスしようとしているドメインが一致するかを確認
      - 証明書に記載された有効期限を過ぎていないかを確認
    - TLSハンドシェイクの続行
      - 暗号化されたセッションを開始

### ワークショップ

- EC2(UbuntuServer)を立てて、実際にHTTPSサーバーを立ててみた
  - 詳細：https://github.com/nyuusen/web-system-textbook/tree/main/aws/web-server

## Chapter7 HTTP/2,HTTP/3対応のHTTPSサーバー

- HTTP1.1の課題
  - 一度に複数の画像等を読み込めるように多重リクエストが機能が導入されたものの、初めのリクエストに時間がかかると、後のリクエストが待機状態になる
  - ヘッダー等の目に見えないデータの肥大化
- HTTP/2の主要な機能とその改善ポイント
  - TLS上でHTTPセッションが確立されるため、安全性向上
  - 1つのTCPコネクション内で複数のHTTPリクエストとレスポンスを同時に送受信可能となり、通信の効率性向上
- HTTP/2化する方法
  - 非常に簡単で、Nginx設定ファイルを書き換えるだけ(使用しているNginxのバージョンがHTTP/2に対応している必要あり)

## Chapter8 大規模Webシステム

- プロキシサーバー
  - クライアント側のネットワークで動作：フォワードプロキシサーバー
  - サーバー側のネットワークで動作：リバースプロキシサーバー
    - ロードバランサーやCDNはリバースプロキシサーバーに該当する
- キャッシュ
  - ブラウザキャッシュとサーバーキャッシュ
- ロードバランサー(LB)
  - 暗号化通信をLBが担うことでWebサーバーの負荷を軽減する
  - LBはネットワークのゲートウェイ側に設置するので、セキュリティ管理を集約できる
- CDN
  - CDNの仕組み
    - 近い場所にあるキャッシュサーバーにアクセスする仕組みとしては、DNSを用いた方法が一般的
    - 専用のDNSサーバーがIPアドレスからどの地域のISPなのかを調べ、あらかじめ用意されているデータベースと照合し、地理的に一番近いキャッシュサーバーのIPアドレスを返している
