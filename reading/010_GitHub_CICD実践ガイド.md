# GitHub CICD実践ガイド

## 1章 ソフトウェア開発とGitHub

- 継続的インテグレーションとは？
  - コードの変更を頻繁にコードベースに統合し、正しく動作するかを繰り返し検証する
  - 統合頻度が上がるとコンフリクトが減る
  - 繰り返して検証を行うとバグを発見すれば素早く修正できる
  - ソフトウェアが安定して動けば、ユーザーの満足度も向上する
- 継続的デリバリーとは？
  - リリースしないとユーザーには価値を提供できない
  - いつでも安全にリリースできる状態を保ち、ソフトウェアを繰り返し改善する
  - CIとCDは同列の概念に見えるが、CIはCDに包含される

## 2章 GitHubActionsの基礎概念

- 実行時エラー
  - コマンドの終了ステータスが0ならば成功、0以外ならば失敗見なされる
  - なので、ワークフローでは終了ステータスを適切に返すことが大事
- 手動実行
  - on: workflow_dispatchで手動実行できる
  - inputとして、列挙型となるchoice型の指定が可能
- 定期実行
  - on: schedule: cron()で定期実行できる
  - 時刻はUTCなので注意
- 実行環境
  - GitHub-Hosted Runners
    - GitHubが提供するマネージドな実行環境
    - LargerRunnersというマシンスペック向上したものも利用可能（有料）
    - サポートOSとしては、Linux(Ubuntu)/Windows/macOSがある
    - よく使用するDocker,Node.js,npmなどは既にインストールされている
      - ただし、バージョン固定はできないので、バージョン固定で使用したい場合は、ワークフローの中で自分でインストールする必要ある
    - エフェメラルという特性
      - ジョブ終了時に破棄されるので、毎回クリーンな環境でジョブを実行できる
      - この特性は一貫性向上に貢献している
  - Self-Hosted Runners
    - 利用者が実行環境を用意する
- MarketPlace
  - 再利用できるワークフローが公開されている
  - 著名な組織にはVerifiedCreatorsマークがついているので、そういうのを利用するとセキュリティ不安が低減する（100%安全とは言い切れないが）
- 料金
  - パブリックリポジトリなら無料
  - プライベートは使用時間とストレージ使用量で計算される
  - 月毎に無料枠があり、それを超えると課金が発生するが、支払い設定をしていない場合は実行できなくなるだけ（なので安心できる）
  - 使用時間は、実行時間×ランナーごとの料率で計算される
    - 料率はubuntuが1,Windowsが2,macOSが10なので、なるべくUbuntuを利用するのがオススメ

## 3章 ワークフロー構文の基礎

### 環境変数

- 単一のワークフローで使用できる
- envで定義する
- ワークフロー・ジョブ・ステップで定義可能
  - 定義した場所で、環境変数のスコープが異なる
- 中間環境変数
  - コンテキスト(github.base_refのように参照できるもの)は、各ジョブ(ステップ)の中で直接スクリプトに埋め込むのはNG
    - 理由: スクリプトインジェクションにリスクがあるため
  - `env`の中で一度変数展開し、スクリプト内ではダブルクオテーションで囲むことが推奨される
    - 変数展開することでメモリ上で保存されるので、スクリプト生成プロセスには生成プロセスには相互作用しないため
  - GHAに限らず、シェルスクリプト全体で言えること

### Variables

- 複数のワークフローで使用できる
- varsコンテキストでアクセスする
- こちらも参照時は中間環境変数経由(envの中で環境変数に展開してから)が推奨

### Secrets

- 以下の特徴がある
  - 登録した値は暗号化され、GitHub内で安全に管理される
  - ログ出力時はマスクされる
  - 登録後の値確認は不可となる
- ログマスクのアルゴリズムは完全一致のみ、1文字スペースを加えたりするだけで出力されてしまうので、ログマスクは当てにしないようにする
  - そもそもsecretsの値はログ出力しないようにしましょう

### expressions(式)

- `${ example }`のような形で定義
- リテラルや演算子などが使用可能
- 比較演算の際、GHAでは異なる型の値を比較すると、勝手に値が変換されるので注意
- オブジェクトフィルター
  - 配列やオブジェクトから指定したプロパティを抜き出し、配列を生成する
  - `${{ github.event.*.html_url }}`のような形で`*`を使用する

### 条件分岐(if)

- ifの少し面白い使い方として、最初のジョブへ条件分岐を定義し、特定の条件でスキップするようにすると、ワークフロー自体の実行がスキップできる
  - 使用時間もゼロになり、コスト削減につながる

### ネーミング

- 実行ログが見やすくなるのでジョブ名やステップ名はきちんと書く
- run-nameは、nameとは異なり、コンテキストが利用できる
  - `run-name: Run by ${{ github.actor }}`

### ステップ間のデータ共有

- 2つのやり方がある
  - GITHUB_OUTPUT環境変数
    - 定義: echo "<key>=<value>" >> "${GITHUB_OUTPUT}"
    - 参照: ${{ steps.<step-id>.outputs.<key> }}
    - 参照方法を見ると分かる通り、ステップ間の依存関係が明白
  - GITHUB_ENV環境変数
    - 定義: echo "<key>=<value>" >> "${GITHUB_ENV}"
    - 参照: ${GITHUB_ENV}
    - ステップIDの指定が不要なので、どのステップで環境変数を設定したかを意識する必要ない
    - 異なる複数のステップで、同じ値を参照する場合に使える（ただしステップ間の依存がわかりづらくなる）
    - これで定義したものは、事実上グローバル変数なので、ワークフローが大きくなるとバグの原因になるので注意が必要
  - **特にこだわりなければ、GITHUB_OUTPUTを使用する**

### GitHub APIの実行

- GitHubHostedRunnerの場合は、GitHub CLIがインストールされているのでそれを使うと良い
- API(CLI)の実行にはトークンが必要
  - GHAには簡単に使えるクレデンシャルが利用できる
  - ワークフロー開始時に自動生成、終了すると自動的に破棄
  - 有効期限は、ワークフロー実行中のみなので、万が一漏れても影響範囲は限定的
  - 取得方法は、`${{ secrets.GITHUB_TOKEN }}` もしくは `${{ github.token }}`
    - どちらでも良いので、どちらかに統一するのが良い
  - トークンの指定は、`GITHUB_TOKEN`もしくは`GH_TOKEN`という名前の環境変数をセットするだけで、自動で読み込んでくれる
- パーミッション
  - ジョブレベルとワークフローレベルで指定可能
  - スコープ(contents, pull-requests等)とそれに対するアクション(read, write, none)を設定する
  - ただしワークフローを実行しているリポジトリ以外のアクセスは許可されない
  - パーミッションを明示的に定義していない場合、自動でソースコードの読み込み許可はされる
    - 一方、明示的な定義をする場合は、この暗黙的な挙動は無視されるので注意
- パーミッション周りのトラブルシューティング
  - ワークフロー実行ログのSet up jobの中に、GITHUB_TOKEN Permissionsがあるので、そこで実行時のパーミッションを確認できる

### スターターワークフロー

- GitHubリポジトリのActionsからNew Workflowを選択すると、ワークフローのコレクションが並んでいるので、参考にできそう
  - https://github.com/actions/starter-workflows?tab=readme-ov-file

## 4章 継続的インテグレーションの実践

- 大体以下の流れでワークフローを構成する
  - checkout
  - setup(ex: actions/setup-go)
  - リントやテストの実行
- フィルター
  - pathsと他の条件を指定するとAND条件になる
- 静的解析
  - actionlintは、GHAワークフローの静的解析を行ってくれるので便利
- 使用時間の削減（どのワークフローでも有用な設定）
  - ジョブ・ステップレベルのタイムアウト設定
    - どのワークフローにも設定するようにする（GHAのデフォルト値は360分と大変長いため）
  - 自動キャンセル（新しいコミットが追加されたら、古いコミットで動作しているワークフローを自動でキャンセルする）
- シェル
  - ステップごとに起動シェルをshellキーで設定可能
  - Ubuntuの場合、省略時はbashだが、shellキーの指定有無で起動オプションが変更される
  - 全ステップに書くのは面倒なので、ワークフローのトップレベルにデフォルト設定(defaults句)するのが良い
  - デフォルトシェルにはデメリットは存在しないので、全てのワークフローに機械的に入れるのがオススメ

### Concurrency

- ワークフローはイベント駆動なので、イベントが発生すると起動、さらにまたイベントが発生すると起動することになる
- 起動制御できる仕組みとして、Concurrencyがある
- `concurrency: <group-name>`とすることで、同一グループの多重制御が設定できる
  - さらに`cancel-in-progress: true`で自動キャンセルの設定も可能（プルリクエストで最新ではないコミットのCIとかに有効）

### CIの黄金律

- 「クリーンに保つ」
  - 全てのステータスチェックが成功した時だけマージできるようにする
- 「高速に実行する」
  - CIの実行が遅いと、待ち時間に他の作業→CIで失敗したらその対応する時にコンテキストスイッチが必要になる
  - 時間の無駄だし、開発効率の低下につながる
  - CIのスピードは大切で、理想は5分以内、遅くとも10分以内に終わらせるように
- 「ノイズを減らす」
  - CIからのフィードバックで価値ある情報の「シグナル」とそうではない「ノイズ」
  - 判断基準としては、その情報を受け取り、これは気にしなくて良いやと流したならそれがノイズ
  - ノイズがあると、シグナルもスルーされてしまうので、ノイズは意識的に減らす