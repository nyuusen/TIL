# GitHub CICD実践ガイド

## 1章 ソフトウェア開発とGitHub

- 継続的インテグレーションとは？
  - コードの変更を頻繁にコードベースに統合し、正しく動作するかを繰り返し検証する
  - 統合頻度が上がるとコンフリクトが減る
  - 繰り返して検証を行うとバグを発見すれば素早く修正できる
  - ソフトウェアが安定して動けば、ユーザーの満足度も向上する
- 継続的デリバリーとは？
  - リリースしないとユーザーには価値を提供できない
  - いつでも安全にリリースできる状態を保ち、ソフトウェアを繰り返し改善する
  - CIとCDは同列の概念に見えるが、CIはCDに包含される

## 2章 GitHubActionsの基礎概念

- 実行時エラー
  - コマンドの終了ステータスが0ならば成功、0以外ならば失敗見なされる
  - なので、ワークフローでは終了ステータスを適切に返すことが大事
- 手動実行
  - on: workflow_dispatchで手動実行できる
  - inputとして、列挙型となるchoice型の指定が可能
- 定期実行
  - on: schedule: cron()で定期実行できる
  - 時刻はUTCなので注意
- 実行環境
  - GitHub-Hosted Runners
    - GitHubが提供するマネージドな実行環境
    - LargerRunnersというマシンスペック向上したものも利用可能（有料）
    - サポートOSとしては、Linux(Ubuntu)/Windows/macOSがある
    - よく使用するDocker,Node.js,npmなどは既にインストールされている
      - ただし、バージョン固定はできないので、バージョン固定で使用したい場合は、ワークフローの中で自分でインストールする必要ある
    - エフェメラルという特性
      - ジョブ終了時に破棄されるので、毎回クリーンな環境でジョブを実行できる
      - この特性は一貫性向上に貢献している
  - Self-Hosted Runners
    - 利用者が実行環境を用意する
- MarketPlace
  - 再利用できるワークフローが公開されている
  - 著名な組織にはVerifiedCreatorsマークがついているので、そういうのを利用するとセキュリティ不安が低減する（100%安全とは言い切れないが）
- 料金
  - パブリックリポジトリなら無料
  - プライベートは使用時間とストレージ使用量で計算される
  - 月毎に無料枠があり、それを超えると課金が発生するが、支払い設定をしていない場合は実行できなくなるだけ（なので安心できる）
  - 使用時間は、実行時間×ランナーごとの料率で計算される
    - 料率はubuntuが1,Windowsが2,macOSが10なので、なるべくUbuntuを利用するのがオススメ

## 3章 ワークフロー構文の基礎

### 環境変数

- 単一のワークフローで使用できる
- envで定義する
- ワークフロー・ジョブ・ステップで定義可能
  - 定義した場所で、環境変数のスコープが異なる
- 中間環境変数
  - コンテキスト(github.base_refのように参照できるもの)は、各ジョブ(ステップ)の中で直接スクリプトに埋め込むのはNG
    - 理由: スクリプトインジェクションにリスクがあるため
  - `env`の中で一度変数展開し、スクリプト内ではダブルクオテーションで囲むことが推奨される
    - 変数展開することでメモリ上で保存されるので、スクリプト生成プロセスには生成プロセスには相互作用しないため
  - GHAに限らず、シェルスクリプト全体で言えること

### Variables

- 複数のワークフローで使用できる
- varsコンテキストでアクセスする
- こちらも参照時は中間環境変数経由(envの中で環境変数に展開してから)が推奨

### Secrets

- 以下の特徴がある
  - 登録した値は暗号化され、GitHub内で安全に管理される
  - ログ出力時はマスクされる
  - 登録後の値確認は不可となる
- ログマスクのアルゴリズムは完全一致のみ、1文字スペースを加えたりするだけで出力されてしまうので、ログマスクは当てにしないようにする
  - そもそもsecretsの値はログ出力しないようにしましょう

### expressions(式)

- `${ example }`のような形で定義
- リテラルや演算子などが使用可能
- 比較演算の際、GHAでは異なる型の値を比較すると、勝手に値が変換されるので注意
- オブジェクトフィルター
  - 配列やオブジェクトから指定したプロパティを抜き出し、配列を生成する
  - `${{ github.event.*.html_url }}`のような形で`*`を使用する

### 条件分岐(if)

- ifの少し面白い使い方として、最初のジョブへ条件分岐を定義し、特定の条件でスキップするようにすると、ワークフロー自体の実行がスキップできる
  - 使用時間もゼロになり、コスト削減につながる

### ネーミング

- 実行ログが見やすくなるのでジョブ名やステップ名はきちんと書く
- run-nameは、nameとは異なり、コンテキストが利用できる
  - `run-name: Run by ${{ github.actor }}`

### ステップ間のデータ共有

- 2つのやり方がある
  - GITHUB_OUTPUT環境変数
    - 定義: echo "<key>=<value>" >> "${GITHUB_OUTPUT}"
    - 参照: ${{ steps.<step-id>.outputs.<key> }}
    - 参照方法を見ると分かる通り、ステップ間の依存関係が明白
  - GITHUB_ENV環境変数
    - 定義: echo "<key>=<value>" >> "${GITHUB_ENV}"
    - 参照: ${GITHUB_ENV}
    - ステップIDの指定が不要なので、どのステップで環境変数を設定したかを意識する必要ない
    - 異なる複数のステップで、同じ値を参照する場合に使える（ただしステップ間の依存がわかりづらくなる）
    - これで定義したものは、事実上グローバル変数なので、ワークフローが大きくなるとバグの原因になるので注意が必要
  - **特にこだわりなければ、GITHUB_OUTPUTを使用する**

### GitHub APIの実行

- GitHubHostedRunnerの場合は、GitHub CLIがインストールされているのでそれを使うと良い
- API(CLI)の実行にはトークンが必要
  - GHAには簡単に使えるクレデンシャルが利用できる
  - ワークフロー開始時に自動生成、終了すると自動的に破棄
  - 有効期限は、ワークフロー実行中のみなので、万が一漏れても影響範囲は限定的
  - 取得方法は、`${{ secrets.GITHUB_TOKEN }}` もしくは `${{ github.token }}`
    - どちらでも良いので、どちらかに統一するのが良い
  - トークンの指定は、`GITHUB_TOKEN`もしくは`GH_TOKEN`という名前の環境変数をセットするだけで、自動で読み込んでくれる
- パーミッション
  - ジョブレベルとワークフローレベルで指定可能
  - スコープ(contents, pull-requests等)とそれに対するアクション(read, write, none)を設定する
  - ただしワークフローを実行しているリポジトリ以外のアクセスは許可されない
  - パーミッションを明示的に定義していない場合、自動でソースコードの読み込み許可はされる
    - 一方、明示的な定義をする場合は、この暗黙的な挙動は無視されるので注意
- パーミッション周りのトラブルシューティング
  - ワークフロー実行ログのSet up jobの中に、GITHUB_TOKEN Permissionsがあるので、そこで実行時のパーミッションを確認できる

### スターターワークフロー

- GitHubリポジトリのActionsからNew Workflowを選択すると、ワークフローのコレクションが並んでいるので、参考にできそう
  - https://github.com/actions/starter-workflows?tab=readme-ov-file

## 4章 継続的インテグレーションの実践

- 大体以下の流れでワークフローを構成する
  - checkout
  - setup(ex: actions/setup-go)
  - リントやテストの実行
- フィルター
  - pathsと他の条件を指定するとAND条件になる
- 静的解析
  - actionlintは、GHAワークフローの静的解析を行ってくれるので便利
- 使用時間の削減（どのワークフローでも有用な設定）
  - ジョブ・ステップレベルのタイムアウト設定
    - どのワークフローにも設定するようにする（GHAのデフォルト値は360分と大変長いため）
  - 自動キャンセル（新しいコミットが追加されたら、古いコミットで動作しているワークフローを自動でキャンセルする）
- シェル
  - ステップごとに起動シェルをshellキーで設定可能
  - Ubuntuの場合、省略時はbashだが、shellキーの指定有無で起動オプションが変更される
  - 全ステップに書くのは面倒なので、ワークフローのトップレベルにデフォルト設定(defaults句)するのが良い
  - デフォルトシェルにはデメリットは存在しないので、全てのワークフローに機械的に入れるのがオススメ

### Concurrency

- ワークフローはイベント駆動なので、イベントが発生すると起動、さらにまたイベントが発生すると起動することになる
- 起動制御できる仕組みとして、Concurrencyがある
- `concurrency: <group-name>`とすることで、同一グループの多重制御が設定できる
  - さらに`cancel-in-progress: true`で自動キャンセルの設定も可能（プルリクエストで最新ではないコミットのCIとかに有効）

### CIの黄金律

- 「クリーンに保つ」
  - 全てのステータスチェックが成功した時だけマージできるようにする
- 「高速に実行する」
  - CIの実行が遅いと、待ち時間に他の作業→CIで失敗したらその対応する時にコンテキストスイッチが必要になる
  - 時間の無駄だし、開発効率の低下につながる
  - CIのスピードは大切で、理想は5分以内、遅くとも10分以内に終わらせるように
- 「ノイズを減らす」
  - CIからのフィードバックで価値ある情報の「シグナル」とそうではない「ノイズ」
  - 判断基準としては、その情報を受け取り、これは気にしなくて良いやと流したならそれがノイズ
  - ノイズがあると、シグナルもスルーされてしまうので、ノイズは意識的に減らす

### テスト

- 単体テストの割合を増やす
- フレーキーテストを放置しない（閾値を超えるとテスト全体が信頼されなくなる）
  - Googleソフトウェアエンジニアリングでは閾値は1％とされている
- 遅いテストは実行タイミングをPRマージの時に限定するなど工夫する
- 使用しているテストツールで以下のような機能を利用する
  - 部分実行
  - 並列実行
  - シャッフル実行（テスト間の隠れた依存関係も洗い出せる）
  - カテゴリ実行（スローテスト用のカテゴリを作ってそれだけ実行しないみたいな）

### 静的解析

- 不要な警告は無視するのではなく抑止する 
  - ignoreやsuppressのキーワードで検索する
  - 抑止理由はコメントやコミットメッセージに残しておく


## 第5章 運用しやすいワークフロー設計

- 長期運用で役立つプラクティスの紹介

### ロギング

- ワークフローの再実行時の「Enable debug logging」を有効にすると、デバッグログが確認できる
- デバッグログには以下がある
  - ステップデバッグログ
    - ステップのログの詳細（ステップステータスや各種コンテキスト）をトレースできる
    - SecretsまたはVariablesに「`ACTIONS_STEP_DEBUG`」をtrueで登録しておくことで、これらの値も確認できる
  - 他は内部実装者向けだったりするので、割愛
- Bashのトレーシングオプション
  - デバッグログよりシンプルで、どんなコマンドが実行され、結果はなんだったのかを知りたいケースで使用する
  - Bashのトレーシングオプションは、`set -x`を実行するだけなので、手軽だが強力
  - 全てのコマンドが実行前に表示されるようになり、どのコマンドがどのような引数で実行されているかを確認できる
- ログのグルーピング、手動マスク等もある

### レポーティング

- アノテーション
  - `echo "::error::This is error"`みたいな形で書くとジョブページにみやすい形で表示
- ジョブサマリー
  - シンプルなテキストならアノテーションで十分だが、複数行表示したい場合等はマークダウン形式で出力される`${GITHUB_STEP_SUMMARY}`が便利

### 複数ジョブの実行制御

- デフォルトでは複数のジョブを実行すると並列実行される
  - 並列実行は、全体の実行時間を短縮できる
  - もしジョブの実行時間の長さに問題がある場合は、ジョブを細かく分割し、並列実行させるというアプローチもある
- 逐次実行させたい場合は、`needs`を使用する
- ジョブ間のデータ共有
  - $GITHUB_OUTPUT環境変数に出力し、stepsコンテキスト経由で受け渡す
  - 受け取る側は、needsコンテキストを経由で受け取る

### Environments

- 環境差分をパラメータ化でき、VariablesとSecretsがある
- 参照方法は、通常のVariablesとSecretsと同一(vars.xxx, secrets.xxx)
- よくあるのはワークフローの入力値で環境名をもらい、それをenvironmentsにセットし、同じ変数名(環境ごとに値が異なる)を参照

### キャッシュ

- actions/cachedでGHA上にキャッシュとその利用が可能
- 実行時のパラメータとして
  - key: キャッシュキー。生成と保存に利用する。
  - path: キャッシュ対象となるディレクトリ/ファイルパス。
  - restore-keys: キャッシュミス時のリストアキーを複数指定する。
- キャッシュ復元時に挙動
  - ①keyキーに定義したキャッシュキーと厳密に一致するキャッシュを探す
  - ②リストアキーの定義順に、プレフィックスが一致するキャッシュを探す
  - リストアキーは省力可能であり、これはパッケージマネージャーと併用するときに威力を発揮する
    - 大半のパッケージマネージャーはキャッシュにないファイルだけダウンロードするように振る舞う
- キャッシュは、7日以上アクセスされないと自動削除される
  - ブラウザからリポジトリ画面で手動削除も可能
- 合計サイズは、リポジトリで10GBまで

#### キャッシュキーの設計

- プラットフォームごとに異なるキャッシュを利用するようにする
  - キャッシュは最低でもOSごとに分離する
  - 他にもCPUアーキテクチャや言語バージョン、パッケージマネージャーもキャッシュキーの候補
  - 例えば、OSとCPUアーキテクチャでキャッシュを分離するなら: `key: example-${{ runner.os }}-${{ runner.arch }}`
- 依存関係を更新した時だけキャッシュを変更するようにする
  - package-lock.jsonのようなロックファイルがある場合、そのファイルハッシュをハッシュキーに指定する
    - `hashfiles('**/package-lock.json)`
  - ロックファイルが更新されない限り、キャッシュが利用されるようになる

### アーティファクト

- ワークフロー内で生成したファイルをアーティファクトと呼ぶ
- アーティファクトはGitHubストレージへ一時的に保存ができる
  - ビルドしたバイナリやメトリクスデータの保存に利用できる
- アーティファクトの保存はデフォルト90日で、保存時にパラメータ(retention-days)で指定可能
  - プライベートリポジトリだとストレージ容量は課金対象のため、保存期間を短くすると節約できる

## 6章 アクションによるモジュール化

- ここでいう「アクションによるモジュール化」とは、ワークフローにおける小さな部品（ステップやコマンドの小さな単位）をモジュール化すること
- ランナーは、呼び出し元ワークフローに依存する
- アクションの実装方式は以下の3つがある
  - Composite: YAMLで定義
  - JavaScript: JSで定義
  - Docker Container: Dockerで動かす(ビルド・起動するDockerfileを指定)
    - これらはrunsのusingキーで指定する(ex: `using: composite`)
- アクションのロケーションは「ローカル」と「リモート」がある
  - リモート: `uses: actions/checkout@v4`
    - URLと連動する
    - `@v4`の部分はGitのタグ（ブランチやコミットハッシュも指定可能）
  - ローカル: `uses: ./.github/actions/hello/`
    - 先頭部分が.であることが目印
    - ルートディレクトリを起点にパスを記述する

### CompositeAction

- メタデータファイル(action.yml)が必要
- メタデータ構文のワークフロー構文との違いや注意点
  - シェル指定が必須
  - githubコンテキストのeventプロパティの使用は避ける
    - アクションはトリガー指定ができないので、呼び出し元のワークフローによりeventの中身がガラリと変わるため
  - variablesとsecretsは直接参照できない
    - inputとして渡す必要あり
      - secretsを渡したらログ出力時のマスクはしてくれる
  - 環境変数のスコープはワークフローに準拠する
    - ワークフロー側で定義した環境変数は参照できるし、アクション側で書き出した環境変数はワークフロー側からも参照可能
  - パーミッション定義できない
    - ワークフロー側で制御するようにする
    - つまり呼び出し側ワークフローでパーミッション定義を忘れると実行エラーが発生するので、どのようなパーミッションが必要かはREADMEなどに残しておくのがオススメ

### アクション設計プラクティス

- 認知負荷の低減
  - 利用者はコードが読みたいのではなく、アクションを使いたいだけ
  - なのでアクションの名前と概要はきちんとわかりやすいように書く（input/outputも）
- `secrets.GITHUB_TOKEN`の取り方
  - アクションからsecretsは参照できないので`secrets.GITHUB_TOKEN`は参照できないが、`github.token`で同じ値を参照できる
- スクリプトの切り出し  
  - 内部ロジックが大きくなってきたらshファイルとして別で切り出すと良い
  - 切り出したshファイルは、`GITHUB_ACTION_PATH`環境変数で実行する必要がある
    - run句に単純なshファイルへの相対パスを指定するだけでは実行できない
- 環境変数による暗黙的な依存の回避
  - ワークフローとアクションで相互に環境変数は参照できるが、必要な値はinputs/outputsで明示的に受け渡すようにするのが良い
  - コードが追いづらくなるのと、意図せず壊れてしまうリスクがある
- ロググループ化の活用
  - まず大前提としてきちんとログを出力する（デバッグ効率が圧倒的に良くなるため）
  - CompositeActionのログはステップごとに分割されないのでログを追うのが難しくなる
  - なのでロググループ化を活用する

### アクションとNodeバージョン

- GitHubが提供する多くのアクションはJSで実装されている
- Nodeバージョンが上がるとアクションのメジャーバージョンが上がることが多い
- このバージョンアップ作業が地味に大変な作業...


## 7章 クリーンなリポジトリの維持

### リポジトリルール

- ブランチプロテクションルールを設定しよう
- コードオーナーを設定して全てのコードにオーナーシップを維持しよう
  - 自動でコードオーナーにレビュー依頼が飛ぶ
- シークレットスキャンを導入して、秘匿情報混入を検出しよう
  - コードやIssueの本文やコメントなどもチェックしてくれる
  - GitHubが定期的にチェックする（つまり事後）
  - プッシュプロテクションをEnableにすると、プッシュするタイミングでチェックが走る

### ドキュメント

- READMEは読み手のことを考える
- LICENSEは確認するようにする
  - MITは、責任とらないけど自由に使ってねくらいのニュアンス
- コミュニティヘルスファイル
  - CONTRIBUTING.md: コントリビューション方法のガイド（PRやIssueの出し方、コーディング規約）
  - CODE_OF_CONDUCT.md: 行動規範
  - SECURITY.md: 脆弱性報告方法など

## 8章 Dependabotによる依存関係バージョンアップ

- ソフトウェアは何もしないと壊れるので、変更し続ける必要がある
  - 依存関係の管理には、検知・把握・実装・テストという活動が必要
- Dependabotには以下3つの依存関係の管理をサポートする機能がある
  - Dependabot version updates: 最新バージョンへの自動アップデート
  - Dependabot security updates: 脆弱性を含むバージョンの自動アップデート
  - Dependabot alerts: 脆弱性が含まれるバージョンのアラート通知
- ワークフローで実践
  - ブランチプロテクションルールを設定し、全てのステータスチェックを行ってからマージしたい場合
    - GitHub CLIのmergeコマンドに`--auto`をつけることで、全ワークフローの成功状態になった後に、自動でマージしてくれる
- Dependabotが起動したワークフローは通常のsecretsへのアクセスができないので、Dependabot用のsecretsを登録する必要があるので注意
  - 厄介なのが何もエラーが出ず、空文字で処理が進むので、頭の片隅に入れておくと良い
- dependabot/fetch-metadataアクションを活用する
  - Dependabotが起動するワークフローで使用可能で、バージョンアップ・依存関係の種類、パッケージエコシステムを取得できる
  - 有効活用の例
    - パッチバージョンの場合は自動マージ
    - 開発環境向けの変更は自動マージ
    - GHA向けの変更は自動マージ
    - このように少しでも手動対応量を減らすことで、少しでも楽をする

## 9章 GitHub Releasesによるリリース自動化

- バージョニング
  - いつどんな変更が行われたのかをバージョンを併記してユーザーに知らせることができる
  - トラブル時はバージョン情報をやり取りすることで関係者間の意思疎通が楽になる
  - 開発者としてもどのバージョンで不具合が発生したかがわかれば、修正が楽になる
- セマンティックバージョニング
  - メジャー.マイナー.パッチという構成のバージョニング方式
  - 順序性だけでなく、後方互換性に関心を寄せているのが特徴
  - 完璧ではない（後方互換性が個人の考え方やスキルに依存する点）が、有名であること視認性が高いことで、選択としては無難である
- Gitタグの保護はやっておこう（ブランチ保護と同じような感じ）
  - ReleasesがGitタグに依存しており、そのGitタグが削除された場合、リリースノートは下書き状態となってしまうため

## 10章 GitHub Packagesによるパッケージ管理

- パッケージエコシステム
  - npmやMavenなどの言語パッケージ、HomebrewなどのOSパッケージ、Dockerなどのコンテナイメージもパッケージの一種
  - ソフトウェアのインストール・管理（依存関係の把握、ライブラリが足りなければ自動でダウンロード、新しいバージョンの検知、最新版へのアップデート等）を容易にする
  - 提供者はパッケージマネージャークライアントを通じてパッケージを作成・登録＆メタデータを提供し、利用者はパッケージマネージャークライアントを通じてパッケージを検索・取得・更新＆依存関係を解決する（そしてこの両者をつなぐのがパッケージレジストリ）
- ContainerRegistryの話がメインで、使いそうもないのでスキップ

## 11章 OpenID Connectによるセキュアなクラウド連携

### クラウドプロバイダのクレデンシャル
- クラウドプロバイダは誰がアクセスしようとしているかを「認証」によって判断する
- クレデンシャルは、その認証に利用するもので、ユーザーIDとパスワードもその一種
- 認証する側が、アクセスキーやAPIキーといった呼び名のランダム文字列を発行し、それをクレデンシャルとして利用する
- プログラムがリクエスト時にそのクレデンシャルを一緒に送信することで、認証と認証情報が正しければ正常レスポンスを受け取れる
- 静的クレデンシャル
  - 長期にわたって変更しないパスワードのようなクレデンシャルを静的クレデンシャルという
  - 静的クレデンシャルは長命という欠点があり、漏洩した場合の被害が拡大しやすい
- 一時クレデンシャル
  - こちらは必要なタイミングで都度払い出すので短命
  - ローテーション作業もないので運用も楽
  - OpenID Connectというプロトコルによって実現する
- クラウド連携のアンチパターン
  - 静的クレデンシャルは使用してはいけない
  - かつてはそれしか選択肢がなかったので、記事を探すときは要注意

### OpenID Connect(OIDC)

- これは複数の異なるドメインで認証結果を共有し、協調してサービスを提供するオープンなプロトコル（アイデンティ連携を実現する）
- OAuth2.0を拡張する形で設計されている
- 利点として、GitHub上で静的クレデンシャルの管理が不要になる(一時クレデンシャルを取得するため)＋認証時にアクセス元を細かく制限できる（GHAの場合特定リポジトリのみに許可できる）

### 一時クレデンシャルの取得フロー

- ワークフローで以下の流れで、クラウドプロバイダから最終的に一時クレデンシャルを取得する

1. GitHub OIDC ProviderからOIDCトークンを取得(ワークフロー→GitHub OIDC Provider)
2. OIDCトークンと一時クレデンシャルを交換(GitHub OIDC Provider→クラウドプロバイダ)
3. 一時クレデンシャルで操作

- 大抵の処理は隠蔽されており、私たちは行う作業は以下の2つのみ（準備に若干手間はかかるがメリットが大きい）
  - クラウドプロバイダ側でOIDCに必要なコンポーネントを作成する
  - ワークフローへクラウドプロバイダの認証アクションを組み込む

### OIDC TrustとCloud Roles

- クラウドプロバイダで準備するコンポーネントは以下の2つ
  - **OIDC Trust**: クラウドプロバイダが信頼するOIDC Providerを設定(GitHub OIDC Provider)
    - OIDCトークンで一時クレデンシャルを取得できる理由は、クラウドプロバイダがOIDC Providerを信頼しているため（OIDC Trust）
    - OIDCトークンはJWT形式で、GitHub OIDC Providerの公開鍵を使って署名等の検証が行われる
  - **Cloud Roles**: 一時クレデンシャルのアクセス先とアクセス元を制御
    - 一時クレデンシャルの「アクセス先」を管理する
    - AWSでいうIAMロールのこと

### 認証アクション

- 各クラウドプロバイダは公式で認証アクションを提供しているので、ワークフローからはそのアクションを呼び出すだけで、OIDCが扱える

### 検証作業のリスクヘッジ

- プライベートリポジトリで試す
- 認証パラメータ(AWSアカウントIDやIAMロール名)はSecretsで管理する
  - これらクレデンシャルではないものの、ログ出力時にマスクされるので、謝ってパブリックリポジトリでワークフローを実行しても、第三者へ余計な情報が漏れない

### AWSにおけるOIDC利用準備と連携

- 以下の2つを作成する
  - OIDC Provider
    - AWSがGitHub OIDC Providerを信頼するように設定
  - IAMロール
    - 一時クレデンシャルのアクセス先とアクセス元を制御する
- GHAワークフロー側での設定作業
  - Secrets登録
    - AWSアカウントID
    - IAMロール名
- ワークフロー実装
  - permissions
    - `id-token: write`の設定が必要
      - GitHub OIDC ProviderからOIDCトークン取得に必要
  - aws-actions/configure-aws-credentialsを利用
    - ロールARNとセッション名、デフォルトリージョンをパラメータとして指定する
    - セッション名は、トレーザビリティを目的に、AssumeRole APIに渡すパラメータ名であり、CloudTrailのセッション名として記録される
      - 「誰が・いつ・どのジョブでこのセッションを作ったか分かる」ような情報を含めると便利
      - 例：`"${{ github.workflow }}-${{ github.run_id }}-${{ github.actor }}"`
- CloudRolesのセキュアな運用
  - 他のリポジトリからアクセスできないことを確認しておく
  - CloudRolesは目的ごとに分離する（必要最小限の権限だけ）
  - クラウドプロバイダの設定作業にIaCを導入する

## 12章 コンテナオーケストレーションのデプロイメント

