# ネットワークはなぜつながるのか

# 1章 Webブラウザがメッセージを作る

- ファイルとディレクトリの違い
  - 末尾/をつけるかつけないかの話
  - `example.com/`だと、`example.com`というWebサーバーの`/`(ルート)にあるデフォルトファイルを指定する
- HTTPプロトコル
  - 何を（URI）どうして欲しいか（メソッド）をクライアントからサーバーに送る
- HTTP通信の宛先の指定がIPアドレス行われる理由
  - IPアドレスは4バイトしかないので処理効率が高いため
- ドメインからIPアドレス変換(名前解決)
  - コンピュータが扱いやすいIPアドレス、人間が扱いやすいドメイン、この間をとりもち変換の役割を行うのがDNS
  - クライアントはDNSリゾルバといい、ブラウザに限らず、いろんなアプリケーションが必要としているので、ライブラリという形で提供されている
    - また、ネットワークでデータ送信する機能とセットなっており、そのまとめ方はOSや言語により異なる
    - ほとんどのOSや言語が「Socketライブラリ」と呼ぶものの考え方を採用している
  - 具体的には、C言語で書かれたプログラムの中から`gethostbyname('example.com')`と呼び、IPアドレスが返却される形となる
    - それを受け取ったリゾルバは、アプリケーション側から指定されたメモリ領域にIPアドレスを書き込む
- データ送受信処理（ここの話はP40〜P41を見ながらがわかりやすい）
  - クライアント側の準備
    - まずはドメインからIPアドレスへの変換
    - 次はソケット生成して接続情報を管理（Socketライブラリ内のsocketという関数を実行する）
      - ソケットとは？
        - ホテルチェックイン時のアカウント作成みたいなイメージ（その人が何か注文するたびにそのアカウントに追記していき、そのアカウントを見ればどのような状態＝会計済み等）
        - アカウントのことをソケットといい、アカウントに紐づけられた情報のことを制御情報とし、メモリー領域を用意するのが目的となる
      - その後、ディスクリプタという値をアプリケーションに返す
        - ディスクリプタ＝TCP/IPソフトがそれぞれのアプリケーションに渡す番号札のようなもの
        - 以後、アプリケーションは、TCP/IPソフトにデータ送受信を依頼するとき、このディスクリプタを提出する
    - socketの実行が終わり、ディスクリプタが返ってきたら、次はconnectというプログラムを呼び出して接続動作を実行する
      - サーバーのIPアドレスとTCP/IPソフトに通知する
      - TCP/IPソフトは、渡されたIPアドレスに対して、制御用のバケットを送り、通信開始を知らせる
  - サーバー側の待ち受けの準備
    - socket
      - ソケット生成
    - bind
      - ソケットに「通信を許可するIPアドレス」と「自分自身のポート番号」を登録する
        - 「通信を許可するIPアドレス」は、どこからそれが届いたのかを調べ、許可するか拒否するかの判断に使用する
          - 例：ローカルマシンだけから接続可能にする場合は、`127.0.0.1`を設定
          - 例：どこからでもOKの場合は`0.0.0.0`を設定
        - 「自分自身のポート番号」は、TCP/IPソフトがパケットを受信した時にそれをどのアプリケーションに渡すべきかを
    - listen
      - ソケットがクライアントからの接続を待ち受けるものであることをTCP/IPソフトに通知
    - accept
      - クライアントから通信開始の制御バケットを待ち受ける状態
    - サーバー側でクライアントから通信開始の制御バケットが届いたら
      - bindでIPアドレスして照合するかを確認
      - 応答バケットを送り返す
  - データ送受信
    - ここまでしてようやく準備完了
    - クライアント
      - write
        - 送信データとそのデータの長さを渡す
        - すると、TCP/IPソフトがそのデータをサーバーに送ってくれる
    - サーバー
      - サーバー側のTCP/IPソフトがそのデータを内部のバッファ・メモリに格納する
        - バッファというのは、OSカーネルが管理するメモリ領域であり、TCPバケットが到着するとすぐにソケットに対応したバッファに格納される
        - バッファが
      - **read**が呼び出されると、受信バッファ用のメモリ領域を通知するので、TCP/IPソフトはそのメモリ領域にデータを格納して、サーバープログラムに制御を戻す
        - readを呼び出すのはアプリケーション側
        - readを呼び出した後、カーネルはバッファからアプリのメモリ領域にデータをコピーする
      - サーバ側の処理がなされた後は、**write**を呼び出す
        - この時にレスポンスデータは送信バッファに格納され、クライアントに送り返す
    - close
      - サーバー側から通信終了を知らせる
      - クライアントもcloseを呼び出し、ソケットを抹消
- メモ
  - 以前サーバー側の処理を以下で実装してみたけど、
    - https://github.com/nyuusen/pure-go-web-app/blob/main/server/main.go
  - 基本的にはサーバー側のアプリケーションは、OSの機能を使いながら、ネットワークを介してパケット受信したりしている
  - そのためとして、ソケットを作って、そこに必要な自分の情報をセットして、接続を受け付けている