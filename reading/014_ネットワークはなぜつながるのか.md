# ネットワークはなぜつながるのか

# 1章 Webブラウザがメッセージを作る

- ファイルとディレクトリの違い
  - 末尾/をつけるかつけないかの話
  - `example.com/`だと、`example.com`というWebサーバーの`/`(ルート)にあるデフォルトファイルを指定する
- HTTPプロトコル
  - 何を（URI）どうして欲しいか（メソッド）をクライアントからサーバーに送る
- HTTP通信の宛先の指定がIPアドレス行われる理由
  - IPアドレスは4バイトしかないので処理効率が高いため
- ドメインからIPアドレス変換(名前解決)
  - コンピュータが扱いやすいIPアドレス、人間が扱いやすいドメイン、この間をとりもち変換の役割を行うのがDNS
  - クライアントはDNSリゾルバといい、ブラウザに限らず、いろんなアプリケーションが必要としているので、ライブラリという形で提供されている
    - また、ネットワークでデータ送信する機能とセットなっており、そのまとめ方はOSや言語により異なる
    - ほとんどのOSや言語が「Socketライブラリ」と呼ぶものの考え方を採用している
  - 具体的には、C言語で書かれたプログラムの中から`gethostbyname('example.com')`と呼び、IPアドレスが返却される形となる
    - それを受け取ったリゾルバは、アプリケーション側から指定されたメモリ領域にIPアドレスを書き込む
- データ送受信処理（ここの話はP40〜P41を見ながらがわかりやすい）
  - クライアント側の準備
    - まずはドメインからIPアドレスへの変換
    - 次はソケット生成して接続情報を管理（Socketライブラリ内のsocketという関数を実行する）
      - ソケットとは？
        - ホテルチェックイン時のアカウント作成みたいなイメージ（その人が何か注文するたびにそのアカウントに追記していき、そのアカウントを見ればどのような状態＝会計済み等）
        - アカウントのことをソケットといい、アカウントに紐づけられた情報のことを制御情報とし、メモリー領域を用意するのが目的となる
      - その後、ディスクリプタという値をアプリケーションに返す
        - ディスクリプタ＝TCP/IPソフトがそれぞれのアプリケーションに渡す番号札のようなもの
        - 以後、アプリケーションは、TCP/IPソフトにデータ送受信を依頼するとき、このディスクリプタを提出する
    - socketの実行が終わり、ディスクリプタが返ってきたら、次はconnectというプログラムを呼び出して接続動作を実行する
      - サーバーのIPアドレスとTCP/IPソフトに通知する
      - TCP/IPソフトは、渡されたIPアドレスに対して、制御用のバケットを送り、通信開始を知らせる
  - サーバー側の待ち受けの準備
    - socket
      - ソケット生成
    - bind
      - ソケットに「通信を許可するIPアドレス」と「自分自身のポート番号」を登録する
        - 「通信を許可するIPアドレス」は、どこからそれが届いたのかを調べ、許可するか拒否するかの判断に使用する
          - 例：ローカルマシンだけから接続可能にする場合は、`127.0.0.1`を設定
          - 例：どこからでもOKの場合は`0.0.0.0`を設定
        - 「自分自身のポート番号」は、TCP/IPソフトがパケットを受信した時にそれをどのアプリケーションに渡すべきかを
    - listen
      - ソケットがクライアントからの接続を待ち受けるものであることをTCP/IPソフトに通知
    - accept
      - クライアントから通信開始の制御バケットを待ち受ける状態
    - サーバー側でクライアントから通信開始の制御バケットが届いたら
      - bindでIPアドレスして照合するかを確認
      - 応答バケットを送り返す
  - データ送受信
    - ここまでしてようやく準備完了
    - クライアント
      - write
        - 送信データとそのデータの長さを渡す
        - すると、TCP/IPソフトがそのデータをサーバーに送ってくれる
    - サーバー
      - サーバー側のTCP/IPソフトがそのデータを内部のバッファ・メモリに格納する
        - バッファというのは、OSカーネルが管理するメモリ領域であり、TCPバケットが到着するとすぐにソケットに対応したバッファに格納される
        - バッファが
      - **read**が呼び出されると、受信バッファ用のメモリ領域を通知するので、TCP/IPソフトはそのメモリ領域にデータを格納して、サーバープログラムに制御を戻す
        - readを呼び出すのはアプリケーション側
        - readを呼び出した後、カーネルはバッファからアプリのメモリ領域にデータをコピーする
      - サーバ側の処理がなされた後は、**write**を呼び出す
        - この時にレスポンスデータは送信バッファに格納され、クライアントに送り返す
    - close
      - サーバー側から通信終了を知らせる
      - クライアントもcloseを呼び出し、ソケットを抹消
- **自分用の整理メモ**
  - 以前サーバー側の処理を以下で実装してみたけど、
    - https://github.com/nyuusen/pure-go-web-app/blob/main/server/main.go
  - 基本的にはサーバー側のアプリケーションは、OSの機能を使いながら、ネットワークを介してパケット受信したりしている
  - そのためとして、ソケットを作って、そこに必要な自分の情報をセットして、接続を受け付けている
  - 結局ソケットって何？
    - 色々難しいことが書かれていたけど、シンプルに理解するなら**ソケット＝通信に必要な情報の塊**
      - 必要な情報＝通信状態や接続先情報、送受信バッファ
    - 役割としては**内部（アプリケーション）と外部（ネットワーク）を繋ぐ橋渡し役**
      - ロジックとしてはアプリケーションから通信したい。通信するにはOSカーネルに依頼する必要があるという前提でがある
      - OSカーネルに依頼するにはシステムコール発行が必要でそれがsocketというもの
        - アプリケーションにはSocketライブラリというものがあり、それを通じてソケットを生成する
        - アプリケーションからOSカーネルにソケット生成を依頼し、ソケットはシステムコール発行の対象（＝操作されるカーネル内の構造体）となる
      - ソケットはどのアプリケーションから呼ばれたか？とか外（ネットワーク）からもらった情報を一時的にバッファに格納してくれたりとかやってくれる

# 2章 TCP/IPのデータを電気信号にして送る

- 1章ではブラウザのURL欄に入力されたURLを解読し、それを元にHTTPリクエストを作って、TCP/IPソフトに依頼する所までがブラウザの範囲でそこの説明だった
- 2章ではそのメッセージをサーバーに向けて送り出す所を探検する
- 注意点として、TCP/IPソフトの役割は中身には関知せず、それをそのまま運ぶことが役割である
  - メッセージの中身が見られるのはサーバーに届いてからなので、それまでは中身について見ない
- Socketライブラリ関連の居場所の整理
  - アプリケーション側（ユーザー空間）
    - システムコールを発するAPI
      - ソケット作成指示や接続/待受処理、データ送受信の**指示・制御**
      - 具体的には標準ライブラリ(net等)の内部でシステムコールを発している
    - Socketライブラリはユーザー空間にある関数・APIの集合（ユーザー空間ライブラリ）であり、OSのソケット機能を使いやすくするためのものである
  - OS側（カーネル）
    - socketの基本機能
      - コネクション管理やバッファ管理などの**実体の処理**
- 以下のような構成
  ```
  - アプリケーション
  - Socketライブラリ(DNSリゾルバ)
  - TCP/UDP
  - IP
  ```
- ソケットの実体とは？
  - TCP/IPソフトの内部にあるメモリ領域であり、TCP・UDPどちらを使うかや通信動作がどのような状態かを表す制御情報が格納されている（これがソケットの実体）
  - 通信というのは、遠方にあるマシンとやりとりすることになり、ちゃんと送れているかやエラーが起きていないかなどの情報の管理が重要になる
  - この重要な制御情報を管理しているのが「ソケット」になる
- 流れ
  - ソケットの実体はメモリ領域であるが、最初からメモリ領域があるわけではない
  - OSに依頼してソケット1つ分のメモリ領域を確保する
  - そのメモリ領域に制御情報を記録していく
  - ソケットを作って通信の準備が終わったら、socketは呼び出し元のアプリケーションにディスクリプタを返却する
    - ディスクリプタ：TCP/IPソフトの内部にある多数のソケットの中のどれを指すかを表す情報
  - 以降アプリケーション側からは、通信相手の情報を毎度送る代わりにディスクリプタを通知する
- TCP/IPソフトがやること
  - ①ソケット作成（socket呼び出す）
    - メモリ領域確保
    - 制御情報（IPv4を使う・TCP使う等）を記録
    - socketからディスクリプタが返却される
      - ディスクリプタとは？
        - OSが保持するファイルディスクリプタテーブルの配列インデックス（単なるint型の番号）
          - ファイルディスクリプタテーブル：そのプロセスが現在開いているリソース一覧（ファイル・ソケット）を管理しているテーブル
        - カーネル側ではそのインデックスに紐づかれた本当の構造体のポイントを内部で持っている
    - 以降の処理はディスクリプタを指定することでソケットを特定する
  - ②TCPでパイプを繋ぐ（Socketライブラリのconnectプログラム呼び出し）＝通信相手との接続動作
    - 通信開始を知らせる制御情報をやりとりする
    - アプリケーションからOSに「このソケットで相手のアドレス・ポートに接続してくれ」と依頼する
    - クライアントとサーバーのポートを論理的に接続する＝これはパイプのようなものであり、通り道自体をコネクションと呼ぶ
    - このコネクションはデータ送受信中はずっと存在し続け、送受信が終わり、closeが呼び出された時に通信終了を知らせる制御情報が流れることで、コネクション消滅＋ソケット削除という流れになる
  - ③制御情報を納めたTCPヘッダを作る
    - 「これからデータを送ります」という意味の制御情報を作成する
    - TCPは何らかの送信動作を行う際は「TCPヘッダ」という制御情報をデータに付加する
      - どのフェーズのどの動作か、データが正しく届いたかを確認するための情報、ポート番号など
    - TCPヘッダに含まれるコントロールビット
      - SYN（synchronize）のビットを1にする＝これからデータを送りますという意味
      - ACK（Acknowledge）のビットを1にする＝了解しました
    - 宛先と送信元ポート番号をセット
      - 宛先：アプリケーションからconnect呼び出し時に指定された番号
      - 送信元：無作為に決定（指定したい場合はbindを呼び出すことで可能）
  - ④IPアドレスを納めたIPヘッダを作る
    - TCPヘッダを作ったらそれをIPに渡す
    - するとIPはIPヘッダを作って、TCPヘッダの頭にくっつける
    - IPヘッダの中で一番重要なのはそれをどこに届けるかを表す「宛先IPアドレス」（アプリケーションから指定されるもの）
    - 送信元のIPアドレスもセットする
      - 複数のネットワークインターフェイス（例：LANアダプタなど）がある場合は少し曲者
      - OSのルーティングテーブルに基づいて、送信先IPアドレスから、送信元IPアドレスが決まる
  - ⑤イーサネット用にMACヘッダを作る
    - IPヘッダを作ったら次はMACヘッダを作る
    - IPヘッダに宛先IPアドレスは書いてあるが、イーサネットにはこのTCP/IPの考えが通用しない（異なる方法でパケットを運ぶ必要がある）
    - イーサネットの宛先判断に使うのが「MACヘッダ」となる
    - 送信元MACアドレスをセットする
      - LANアダプタを製造するときにそのROMに書かれているので、LANドライバに依頼して、それを読み込んでMACヘッダにセットする
      - LANドライバは、単なるハードウェア（LANアダプタ）とOSを橋渡しするソフトウェアを指す