# 1章 プログラミング言語化Goとは

- 専用の環境を用意することなくコンパイルできる
- デフォルトでUTF-8サポート
- 並行処理の扱いやすさ
  - 並行処理は難しいが、Goではマルチコアが活かされるようにランタイムが設計されている
- libc非依存

# 2章 開発環境の準備

- バージョン管理ソフトウェアについて
  - Goは後方互換性がほぼ保証されている且つランタイムを固定しないと動作しないなどもないので、pyenvのようなバージョン管理ソフトウェアを使用するメリットは薄い
  - むしろ脆弱性を含んだいつものバージョンが更新されないまま残ってしまうという問題がある
- GOROOTやGOPATH
  - 古いバージョンではこれらを設定する必要があったが、最近のバージョンでは意識しなくて良い
  - go getコマンドでダウンロードされるソースコードは`~/go/pkg`配下に、go installコマンドでインストールされる実行ファイルは`~/go/bin`に格納される

# 3章 基本的な文法

- LabeledBreak
  - ネストしているforループから一気に外側に抜けられる`break label`
- スライス
  - makeで初期化しないと、要素追加時にpanicが発生する
- 文字列
  - 文字列はバイト列で構成されているので添え字を使ってアクセスできる
    - 内部的には、バイト列へのポインタと長さをもつ構造体
  - イミュータブルなので、内容を書き換える際はバイト列に変換する必要がある
    - Goの文字列は、UTF-8エンコードされたバイト列
    - 変換したい値がASCII文字(1バイト)＝英数字のみとわかっているなら、バイトの書き換えでOK
    - マルチバイト文字の場合は、1バイトのみの書き換えだと文字化けしてしまうので、一度runeに変換して、Unicodeレベルで操作する必要がある
  - ``で囲うと複数行のテキストを扱うことができる
    - \も文字列として表示できる
- map
  - 順序は保持しないので、ソートされた状態で処理をしたい場合は先にキーを取り出してソート後にfor-rangeを実行する必要がある
- 構造体
  - 関数に構造体を渡すとコピーが渡されるのでそのオーバーヘッドを無くしたいのであればポインタを渡すようにする
- ポインタ
  - C言語ではスタックのポインタを返すとクラッシュするが、Goではエスケープ解析という仕組みで自動的にヒープに逃してくれる
- ゴルーチン
  - for文の中でゴルーチンを起動し、ループ変数を参照したい場合は、ループ処理の中で新たに変数宣言をする必要がある（ゴルーチンの中でループ変数iを参照する時にはループが終わってしまい、意図した値を参照できないため）
    - もしくは構造体や大きなバイト配列だとコピーにかかるコストが大きくなってしまうので、無名関数として引数に渡すかループカウンタ(i)を使って、ゴルーチン内から直接アクセス（ex: `users[i]`）しても良い
  - Race Condition
    - ゴルーチン呼び出し元とゴルーチン内で同じ変数を参照・更新する際に競合が起きてしまうこと
    - これを避けるためにはsync.Mutexを使って保護する

### モジュール

- replace
  - `go mod edit -replace github.com/mattn/foobar=...`
  - サブディレクトリにgo.modを置いている場合、その親ディレクトリのモジュールをローカルディレクトリにあるものを使うようにする
- go install
  - パッケージをビルドしてインストールする
  - mainパッケージを含んだパッケージをインストールすると実行ファイルがインストールされる
  - CLIプログラムを配布する際は、実行ファイルそのものを配布することもできるが、Goコンパイラをインストールしているユーザーに対しては、go installコマンドを使ってインストールしてもらうことも可能
  - go.modを変更しない

### lintとフォーマット

- go vet
  - 標準で付属する静的解析ツール
- revive
  - 開発継続が断念されたgolintの後継
- golangci-lint
  - たくさん存在するGoの静的解析ツールをひとまとめにして実行してくれるツール
  - GHAのようなCIでテストする際によく使われる
- go fmt
  - 標準で付属するフォーマッタ
  - 設定項目がない

# 第4章 基本テクニックとベストプラクティス

## panicとrecover
- これ以上プログラムを動作してはいけないというケースで使用する
- Goでは復旧可能な例外と復旧不可能な例外がある
  - ゼロ徐算やnilポインタのデリファレンス、配列の境界外アクセス等はランタイムでpanicが呼び出される
    - これらのpanicはrecoverにより復活させることができる
    - recoverから返される値はanyであるが、panic関数の引数を文字列にして呼び出した場合はrecoverからは文字列が返却される
    - 一方ランタイムpanicの場合はerror型が返される
- そもそも意図しないpanicが起きうる＝プログラムにバグがあるということなので、不用意にrecoverを呼び出すべきではない
  - 事前にポインタがnilではないことを確認するなどすべきだし、nilである場合は関数でerrorを返すべき

## init関数

- そのパッケージに含まれるグローバル変数が初期化されたタイミングで自動的に呼ばれる
- ブランクimport(`import _ "github.com/lib/pq"`)を行うことで、pq内のinit関数を利用して、ドライバを登録している

## パッケージ

### fmt

- 数値から文字列への変換: `fmt.Sprint(x)`
  - strconvを使うより簡単
- Stringerインターフェイスが実装されていればその内容を出力する

### log

- PrintとFatalのみ
- 改行していない文字列を渡すと必ず改行が入る

### encoding/json

- 固定のJSON文字列をパースする場合はjson.Unmarshalを使用する
- ネットワーク通信のストリームやファイルなどを扱う場合はデコーダを使う
    - `json.NewDecoder(f).Decode(&data)`
    - これにより巨大なデータであっても入力データとパース済みのstructの両方がメモリに確保されない