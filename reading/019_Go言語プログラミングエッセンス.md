# 1章 プログラミング言語化Goとは

- 専用の環境を用意することなくコンパイルできる
- デフォルトでUTF-8サポート
- 並行処理の扱いやすさ
  - 並行処理は難しいが、Goではマルチコアが活かされるようにランタイムが設計されている
- libc非依存

# 2章 開発環境の準備

- バージョン管理ソフトウェアについて
  - Goは後方互換性がほぼ保証されている且つランタイムを固定しないと動作しないなどもないので、pyenvのようなバージョン管理ソフトウェアを使用するメリットは薄い
  - むしろ脆弱性を含んだいつものバージョンが更新されないまま残ってしまうという問題がある
- GOROOTやGOPATH
  - 古いバージョンではこれらを設定する必要があったが、最近のバージョンでは意識しなくて良い
  - go getコマンドでダウンロードされるソースコードは`~/go/pkg`配下に、go installコマンドでインストールされる実行ファイルは`~/go/bin`に格納される

# 3章 基本的な文法

- LabeledBreak
  - ネストしているforループから一気に外側に抜けられる`break label`
- スライス
  - makeで初期化しないと、要素追加時にpanicが発生する
- 文字列
  - 文字列はバイト列で構成されているので添え字を使ってアクセスできる
    - 内部的には、バイト列へのポインタと長さをもつ構造体
  - イミュータブルなので、内容を書き換える際はバイト列に変換する必要がある
    - Goの文字列は、UTF-8エンコードされたバイト列
    - 変換したい値がASCII文字(1バイト)＝英数字のみとわかっているなら、バイトの書き換えでOK
    - マルチバイト文字の場合は、1バイトのみの書き換えだと文字化けしてしまうので、一度runeに変換して、Unicodeレベルで操作する必要がある
  - ``で囲うと複数行のテキストを扱うことができる
    - \も文字列として表示できる
- map
  - 順序は保持しないので、ソートされた状態で処理をしたい場合は先にキーを取り出してソート後にfor-rangeを実行する必要がある
- 構造体
  - 関数に構造体を渡すとコピーが渡されるのでそのオーバーヘッドを無くしたいのであればポインタを渡すようにする
- ポインタ
  - C言語ではスタックのポインタを返すとクラッシュするが、Goではエスケープ解析という仕組みで自動的にヒープに逃してくれる
- ゴルーチン
  - for文の中でゴルーチンを起動し、ループ変数を参照したい場合は、ループ処理の中で新たに変数宣言をする必要がある（ゴルーチンの中でループ変数iを参照する時にはループが終わってしまい、意図した値を参照できないため）
    - もしくは構造体や大きなバイト配列だとコピーにかかるコストが大きくなってしまうので、無名関数として引数に渡すかループカウンタ(i)を使って、ゴルーチン内から直接アクセス（ex: `users[i]`）しても良い
  - Race Condition
    - ゴルーチン呼び出し元とゴルーチン内で同じ変数を参照・更新する際に競合が起きてしまうこと
    - これを避けるためにはsync.Mutexを使って保護する

### モジュール

- replace
  - `go mod edit -replace github.com/mattn/foobar=...`
  - サブディレクトリにgo.modを置いている場合、その親ディレクトリのモジュールをローカルディレクトリにあるものを使うようにする
- go install
  - パッケージをビルドしてインストールする
  - mainパッケージを含んだパッケージをインストールすると実行ファイルがインストールされる
  - CLIプログラムを配布する際は、実行ファイルそのものを配布することもできるが、Goコンパイラをインストールしているユーザーに対しては、go installコマンドを使ってインストールしてもらうことも可能
  - go.modを変更しない

### lintとフォーマット

- go vet
  - 標準で付属する静的解析ツール
- revive
  - 開発継続が断念されたgolintの後継
- golangci-lint
  - たくさん存在するGoの静的解析ツールをひとまとめにして実行してくれるツール
  - GHAのようなCIでテストする際によく使われる
- go fmt
  - 標準で付属するフォーマッた
  - 設定項目がない