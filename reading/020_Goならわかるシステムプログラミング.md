# Goならわかるシステムプログラミング

## 第1章 Go言語で覗くシステムプログラミングの世界

- 本書では「OSが提供する機能を使ったプログラミング」をシステムプログラミングとして定義する
- Goは、多くのOSの機能を直接扱えて、少ない行数でアプリケーションを作れるので最適
- GoはC/C++の役割を置き換えるか？
  - Noだと思う
  - 性能は落ちるし、バイナリサイズは大きくなる
- VSCodeのデバッグ実行機能を使ってステップインをしてコードをふかぼっていく
  - F12で定義元にジャンプする形でも内部のコードを追っていける
  - 逆にShift + F12で関数などが使われている場所を探すことも可能

## 第2章 低レベルアクセスへの入口1: io.Writer

- Goは抽象化により低レイヤーを扱いやすい構造になっている
- syscall.Writeはファイルディスクリプタ(以後FD)に対して発行する
  - FDに対応するモノは通常のファイルに限られず、標準入出力・ソケット・OS・CPUに内蔵されている乱数生成の仕組みなど、**本来ファイルではないものにもFDが割り当てられ、どれもファイルと同じようにアクセスできる**
- FDは、OSがカーネルのレイヤーで用意している抽象化の仕組み
  - POSIX(Portable Operating System Interface:IEEEが策定し、ISO/IECが標準化したOSのインターフェース規格、OSがアプリケーションんい対して提供すべきAPIやシェルなどの共通ルール集)系OSでも、Windowsだとソケットはファイルとして扱えなかったりする
  - Goは、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備士、OSによる差異を吸収している
    - 標準ライブラリ自体に、全OS分の実装を持っていて、Goがその面倒な部分を吸収してくれている
    - つまり開発者はOSによる差を意識することなくコーディングできる
- io.Writerの例
  - バイト列を受け取り、書き込んだバイト数とエラーを返すという共通の処理にまとめられている
  - 実際にFile型のWriteメソッドはこのインターフェイスを実装している
  - その他のソケットなどもこのメソッドを実装していて、使う側はWriterインターフェイスさえ満たしていれば、**どこに書き込むかを意識せず**に利用できる
    - FileのWriteメソッドはファイルに書き込むし、bytes.Bufferはバッファに書き込むしといった具合
  - 参考: https://mattn.kaoriya.net/software/lang/go/20140501172821.html
- io.Writerのデコレータ
  - デコレータとは、オブジェクトをラップして追加の機能を実現するデザインパターン
  - gzip.NewWriterはio.Writerを受け取り、書き込まれたデータをgzip圧縮するなんてことも可能
- バッファリングなしで書き込むとオーバーヘッドがある？
  - 筆者が検証した限りでは100回くらい出力するCLIツールだと誤差の範囲
  - C言語ができた当時と比べると、OSのコードを呼び出して返ってくるまでのオーバーヘッドも大したことないため、Goはシンプルな実装にしたのかもしれない
  - もし大量の入出力 or 高頻度の入出力を行うのであれば、バッファサイズを決める必要がある
- フォーマットしたデータをio.Writerに書き出す
  - fmt.Fprintfは第一引数がio.Writerなので出力先を外から指定できる
  - `%v`はなんでも表示できるフォーマット指定子で、プリミティブ型でもそうでない型もString()メソッドがあればそれを表示に使って出力してくれる
    - たとえString()がなかったとしても、内部を走査して、良い感じに表示してくれる
- インターフェイスの実装状況を調べる
  - Goでは構造体側にこのインターフェイスを実装するという情報は書かない
  - 引数で渡した時などに自動でチェックされる
  - VSCodeでは、インターフェイスにカーソルを当てて、コマンドパレットから「Go To Implementations」を実行すると、そのインターフェイスの実装を検索できる