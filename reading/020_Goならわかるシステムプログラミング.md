# Goならわかるシステムプログラミング

## 第1章 Go言語で覗くシステムプログラミングの世界

- 本書では「OSが提供する機能を使ったプログラミング」をシステムプログラミングとして定義する
- Goは、多くのOSの機能を直接扱えて、少ない行数でアプリケーションを作れるので最適
- GoはC/C++の役割を置き換えるか？
  - Noだと思う
  - 性能は落ちるし、バイナリサイズは大きくなる
- VSCodeのデバッグ実行機能を使ってステップインをしてコードをふかぼっていく
  - F12で定義元にジャンプする形でも内部のコードを追っていける
  - 逆にShift + F12で関数などが使われている場所を探すことも可能

## 第2章 低レベルアクセスへの入口1: io.Writer

- Goは抽象化により低レイヤーを扱いやすい構造になっている
- syscall.Writeはファイルディスクリプタ(以後FD)に対して発行する
  - FDに対応するモノは通常のファイルに限られず、標準入出力・ソケット・OS・CPUに内蔵されている乱数生成の仕組みなど、**本来ファイルではないものにもFDが割り当てられ、どれもファイルと同じようにアクセスできる**
- FDは、OSがカーネルのレイヤーで用意している抽象化の仕組み
  - POSIX(Portable Operating System Interface:IEEEが策定し、ISO/IECが標準化したOSのインターフェース規格、OSがアプリケーションんい対して提供すべきAPIやシェルなどの共通ルール集)系OSでも、Windowsだとソケットはファイルとして扱えなかったりする
  - Goは、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備士、OSによる差異を吸収している
    - 標準ライブラリ自体に、全OS分の実装を持っていて、Goがその面倒な部分を吸収してくれている
    - つまり開発者はOSによる差を意識することなくコーディングできる
- io.Writerの例
  - バイト列を受け取り、書き込んだバイト数とエラーを返すという共通の処理にまとめられている
  - 実際にFile型のWriteメソッドはこのインターフェイスを実装している
  - その他のソケットなどもこのメソッドを実装していて、使う側はWriterインターフェイスさえ満たしていれば、**どこに書き込むかを意識せず**に利用できる
    - FileのWriteメソッドはファイルに書き込むし、bytes.Bufferはバッファに書き込むしといった具合
  - 参考: https://mattn.kaoriya.net/software/lang/go/20140501172821.html
- io.Writerのデコレータ
  - デコレータとは、オブジェクトをラップして追加の機能を実現するデザインパターン
  - gzip.NewWriterはio.Writerを受け取り、書き込まれたデータをgzip圧縮するなんてことも可能
- バッファリングなしで書き込むとオーバーヘッドがある？
  - 筆者が検証した限りでは100回くらい出力するCLIツールだと誤差の範囲
  - C言語ができた当時と比べると、OSのコードを呼び出して返ってくるまでのオーバーヘッドも大したことないため、Goはシンプルな実装にしたのかもしれない
  - もし大量の入出力 or 高頻度の入出力を行うのであれば、バッファサイズを決める必要がある
- フォーマットしたデータをio.Writerに書き出す
  - fmt.Fprintfは第一引数がio.Writerなので出力先を外から指定できる
  - `%v`はなんでも表示できるフォーマット指定子で、プリミティブ型でもそうでない型もString()メソッドがあればそれを表示に使って出力してくれる
    - たとえString()がなかったとしても、内部を走査して、良い感じに表示してくれる
- インターフェイスの実装状況を調べる
  - Goでは構造体側にこのインターフェイスを実装するという情報は書かない
  - 引数で渡した時などに自動でチェックされる
  - VSCodeでは、インターフェイスにカーソルを当てて、コマンドパレットから「Go To Implementations」を実行すると、そのインターフェイスの実装を検索できる

## 第3章 低レベルアクセスへの入口2: io.Reader

- 外部からデータを読み込むための機能を抽象化しているのがio.Reader
- `func Read(p []byte) (n int, err error)`
  - 引数であるpは、読み込んだ内容を一時的に入れておくバッファ
  - あらかじめmake()でメモリを確保しておく
- 書き込みに比べると前もってバッファを用意してその長さも管理してと少し面倒なので、補助的な関数がいくつか用意されている

- 自分の中での整理用メモ
  - io.Readerは、データがどこにあるか何であるかを一切無視し、データがどう流れてくるかというストリームそのものを抽象化している
  - この「抽象化」がもたらす最大の恩恵は、**「データの出所」と「データの加工ロジック」を完全に切り離せる（疎結合にできる）**ことにある
  - 例えば、os.File（ディスク）、net.Conn（ネットワーク）、bytes.Buffer（メモリ）は実体こそ違えど、すべて io.Reader という共通のインターフェースで扱えるため、一度ロジックを書けばデータの所在を問わず再利用が可能になる
    - 具体的には、ログファイルからデータを読み取り解析するExtractErrorLogという関数があるとする
      - この引数にファイルパスを受け取る形にしてしまうと、ログの提供元がgzipやネットワーク越しになった時にこの関数に修正を加える or 別の関数を作ることが必要になってしまう
      - 引数をio.Readerにしておけば、データの所在がどこであれ、関数を変えることなく、同じ関数を使い回すことができる
- メモリ効率を最大化するストリーム処理の仕組み
  - Read(p []byte) という設計の肝は、**「呼び出し側が用意したバッファを使い回す」**点にある
  - 10GBの巨大なファイルを処理する場合でも、1MBのバッファ（スライス）を一つ用意し、そこにデータを小出しに詰め込んで処理を繰り返せば、メモリ消費量は常に1MBの定数オーダー ($O(1)$) で済む
  - これが Read() []byte（関数側でメモリを確保して返す設計）だった場合、データ量に比例してメモリが膨れ上がり、即座にOOM（Out of Memory）でシステムが沈黙することになる
- デコレータパターンによる「土管」の連結
  - io.Reader は、別の io.Reader をラップして機能を拡張する「デコレータパターン」と非常に相性が良い
  - os.File（生の土管）の上に、gzip.NewReader（解凍機能付きの土管）を被せ、さらにその上に io.LimitReader（流量制限付きの土管）を被せるといった、パイプラインの構築が自由自在に行える
  - **重要なのは、この連結された土管の最上流で Read が呼ばれたとき、「必要な分だけ下流からデータを吸い上げる」というプル型の連鎖が起きること。これにより、解凍や暗号化といった重い処理も、メモリ上に全展開することなく「流しながら」完結させることができる**
- テスト容易性と保守性の向上
  - 関数の引数を io.Reader にしておくことで、本番環境では「巨大なS3上のオブジェクト」を流し込み、テスト環境では strings.NewReader("dummy data") を使って「メモリ上の文字列」を流し込むといった切り替えが容易になる
  - 物理的なリソース（ファイルやネットワーク）への依存を排除し、純粋なデータ処理ロジックのみをクリーンに保てるのが、Goにおける io.Reader の真の価値と言える

### io.Readerの補助関数

- 読み込みの補助関数
  - io.ReadAll(reader)
    - 終端記号にあたるまで全てのデータを読み込んで返す
  - io.ReadFull
    - 決まったバイト数だけ確実に読み込みたい場合に使う
      - サイズが決まっているバイナリデータとか
- コピーの補助関数
  - io.Readerからio.Writerにそのままデータを渡したい時に使う
  - 最もよく使うのがio.Copy()

### Writer,Reader以外のインターフェイス

- io.NopCloser
  - ダミーの何もしないCloseメソッドを持って、io.ReadCloserのフリをする
  - テストの時にstrings.NewReader("For test")などとしたときに便利

### io.Readerを満たす構造体でよく使うもの

- io.Reader/Writerのどちらも満たす構造体が多い
- 標準入力(os.Stdin)
- ファイル
  - io.Reader/Writerのどちらも満たす
- ネットワーク通信
  - net.Dialメソッドで返ってくる構造体net.Conn型はio.Reader/Writerのどちらも満たす
  - `http.ReadResponse(bufio.NewReader(conn), nil)`
    - HTTPレスポンスをパースする泥臭い作業をやってくれ流ので、ヘッダーやボディをプログラムで利用するのに簡単
    - 流れ的にはカーネル空間からユーザー空間(FD)へ、その後バッファリング層へ(bufio内の内部配列)、その後ReadResponseでbufioからデータを少しずつ処理(Peek)していく
- メモリに蓄えた内容をio.Readerとして読み出すバッファ
  - 基本はbytes.Bufferだけ覚えておけば良い

### バイナリ解析用のio.Reader関連機能

- ファイルを読み込みたいが、先頭部分だけが必要な場合：io.LimitReader
- エンディアン変換
  - 現在主流のCPUはリトルエンディアンだが、ネットワーク上で転送されるデータの多くは大きい桁からメモリに格納されるビッグエンディアン
    - なので、ネットワークで受け取ったデータをリトルエンディアンに修正する必要がある
    - `binary.Read(bytes.NewReader(data), binary.BigEndian, &i)`のような形でエンディアンが修正された値が取得できる

### テキスト解析用のio.Reader関連機能

- バイナリ解析の場合は、読み込むバイト数が固定だったり、可変長データの場合でも読み込むバイト数などが事前に示されているのがほとんど
- だが、テキスト解析ではデータ長が決まらずスキャンしながら区切りを探すしかないので、探索しながら読み込んでいく必要がある

#### 改行・単語で区切る

- テキスト解析の基本は改行区切り
- 全部読み込んでしまってから文字列処理で改行に分割するという方法もあるが、io.Readerによる入力ではbufio.Readerを使う方がシンプル
- bufio.Scannerを使うと改行文字を区切りとして行単位で走査できる
  - 取得結果から区切り文字（改行文字）が削除される点は注意
  - 区切り文字はデフォルトは改行文字だが、scanner.split(bufio.ScanWords)として単語区切りにすることもできる

#### データ型を指定して解析

- fmt.Fscan()に第一引数にio.Reader,第二引数以降に変数ポインタを渡すと、その変数にデータが書き込まれる
