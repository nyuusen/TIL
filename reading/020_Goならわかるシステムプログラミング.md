# Goならわかるシステムプログラミング

## 第1章 Go言語で覗くシステムプログラミングの世界

- 本書では「OSが提供する機能を使ったプログラミング」をシステムプログラミングとして定義する
- Goは、多くのOSの機能を直接扱えて、少ない行数でアプリケーションを作れるので最適
- GoはC/C++の役割を置き換えるか？
  - Noだと思う
  - 性能は落ちるし、バイナリサイズは大きくなる
- VSCodeのデバッグ実行機能を使ってステップインをしてコードをふかぼっていく
  - F12で定義元にジャンプする形でも内部のコードを追っていける
  - 逆にShift + F12で関数などが使われている場所を探すことも可能

## 第2章 低レベルアクセスへの入口1: io.Writer

- Goは抽象化により低レイヤーを扱いやすい構造になっている
- syscall.Writeはファイルディスクリプタ(以後FD)に対して発行する
  - FDに対応するモノは通常のファイルに限られず、標準入出力・ソケット・OS・CPUに内蔵されている乱数生成の仕組みなど、**本来ファイルではないものにもFDが割り当てられ、どれもファイルと同じようにアクセスできる**
- FDは、OSがカーネルのレイヤーで用意している抽象化の仕組み
  - POSIX(Portable Operating System Interface:IEEEが策定し、ISO/IECが標準化したOSのインターフェース規格、OSがアプリケーションんい対して提供すべきAPIやシェルなどの共通ルール集)系OSでも、Windowsだとソケットはファイルとして扱えなかったりする
  - Goは、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備士、OSによる差異を吸収している
    - 標準ライブラリ自体に、全OS分の実装を持っていて、Goがその面倒な部分を吸収してくれている
    - つまり開発者はOSによる差を意識することなくコーディングできる
- io.Writerの例
  - バイト列を受け取り、書き込んだバイト数とエラーを返すという共通の処理にまとめられている
  - 実際にFile型のWriteメソッドはこのインターフェイスを実装している
  - その他のソケットなどもこのメソッドを実装していて、使う側はWriterインターフェイスさえ満たしていれば、**どこに書き込むかを意識せず**に利用できる
    - FileのWriteメソッドはファイルに書き込むし、bytes.Bufferはバッファに書き込むしといった具合
  - 参考: https://mattn.kaoriya.net/software/lang/go/20140501172821.html