# Goならわかるシステムプログラミング

## 第1章 Go言語で覗くシステムプログラミングの世界

- 本書では「OSが提供する機能を使ったプログラミング」をシステムプログラミングとして定義する
- Goは、多くのOSの機能を直接扱えて、少ない行数でアプリケーションを作れるので最適
- GoはC/C++の役割を置き換えるか？
  - Noだと思う
  - 性能は落ちるし、バイナリサイズは大きくなる
- VSCodeのデバッグ実行機能を使ってステップインをしてコードをふかぼっていく
  - F12で定義元にジャンプする形でも内部のコードを追っていける
  - 逆にShift + F12で関数などが使われている場所を探すことも可能

## 第2章 低レベルアクセスへの入口1: io.Writer

- Goは抽象化により低レイヤーを扱いやすい構造になっている
- syscall.Writeはファイルディスクリプタ(以後FD)に対して発行する
  - FDに対応するモノは通常のファイルに限られず、標準入出力・ソケット・OS・CPUに内蔵されている乱数生成の仕組みなど、**本来ファイルではないものにもFDが割り当てられ、どれもファイルと同じようにアクセスできる**
- FDは、OSがカーネルのレイヤーで用意している抽象化の仕組み
  - POSIX(Portable Operating System Interface:IEEEが策定し、ISO/IECが標準化したOSのインターフェース規格、OSがアプリケーションんい対して提供すべきAPIやシェルなどの共通ルール集)系OSでも、Windowsだとソケットはファイルとして扱えなかったりする
  - Goは、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備士、OSによる差異を吸収している
    - 標準ライブラリ自体に、全OS分の実装を持っていて、Goがその面倒な部分を吸収してくれている
    - つまり開発者はOSによる差を意識することなくコーディングできる
- io.Writerの例
  - バイト列を受け取り、書き込んだバイト数とエラーを返すという共通の処理にまとめられている
  - 実際にFile型のWriteメソッドはこのインターフェイスを実装している
  - その他のソケットなどもこのメソッドを実装していて、使う側はWriterインターフェイスさえ満たしていれば、**どこに書き込むかを意識せず**に利用できる
    - FileのWriteメソッドはファイルに書き込むし、bytes.Bufferはバッファに書き込むしといった具合
  - 参考: https://mattn.kaoriya.net/software/lang/go/20140501172821.html
- io.Writerのデコレータ
  - デコレータとは、オブジェクトをラップして追加の機能を実現するデザインパターン
  - gzip.NewWriterはio.Writerを受け取り、書き込まれたデータをgzip圧縮するなんてことも可能
- バッファリングなしで書き込むとオーバーヘッドがある？
  - 筆者が検証した限りでは100回くらい出力するCLIツールだと誤差の範囲
  - C言語ができた当時と比べると、OSのコードを呼び出して返ってくるまでのオーバーヘッドも大したことないため、Goはシンプルな実装にしたのかもしれない
  - もし大量の入出力 or 高頻度の入出力を行うのであれば、バッファサイズを決める必要がある
- フォーマットしたデータをio.Writerに書き出す
  - fmt.Fprintfは第一引数がio.Writerなので出力先を外から指定できる
  - `%v`はなんでも表示できるフォーマット指定子で、プリミティブ型でもそうでない型もString()メソッドがあればそれを表示に使って出力してくれる
    - たとえString()がなかったとしても、内部を走査して、良い感じに表示してくれる
- インターフェイスの実装状況を調べる
  - Goでは構造体側にこのインターフェイスを実装するという情報は書かない
  - 引数で渡した時などに自動でチェックされる
  - VSCodeでは、インターフェイスにカーソルを当てて、コマンドパレットから「Go To Implementations」を実行すると、そのインターフェイスの実装を検索できる

## 第3章 低レベルアクセスへの入口2: io.Reader

- 外部からデータを読み込むための機能を抽象化しているのがio.Reader
- `func Read(p []byte) (n int, err error)`
  - 引数であるpは、読み込んだ内容を一時的に入れておくバッファ
  - あらかじめmake()でメモリを確保しておく
- 書き込みに比べると前もってバッファを用意してその長さも管理してと少し面倒なので、補助的な関数がいくつか用意されている

### io.Readerの補助関数

- 読み込みの補助関数
  - io.ReadAll(reader)
    - 終端記号にあたるまで全てのデータを読み込んで返す
  - io.ReadFull
    - 決まったバイト数だけ確実に読み込みたい場合に使う
      - サイズが決まっているバイナリデータとか
- コピーの補助関数
  - io.Readerからio.Writerにそのままデータを渡したい時に使う
  - 最もよく使うのがio.Copy()

### Writer,Reader以外のインターフェイス

- io.NopCloser
  - ダミーの何もしないCloseメソッドを持って、io.ReadCloserのフリをする
  - テストの時にstrings.NewReader("For test")などとしたときに便利

### io.Readerを満たす構造体でよく使うもの

- io.Reader/Writerのどちらも満たす構造体が多い
- 標準入力(os.Stdin)
- ファイル
  - io.Reader/Writerのどちらも満たす
- ネットワーク通信
  - net.Dialメソッドで返ってくる構造体net.Conn型はio.Reader/Writerのどちらも満たす
  - `http.ReadResponse(bufio.NewReader(conn), nil)`
    - HTTPレスポンスをパースする泥臭い作業をやってくれ流ので、ヘッダーやボディをプログラムで利用するのに簡単
    - 流れ的にはカーネル空間からユーザー空間(FD)へ、その後バッファリング層へ(bufio内の内部配列)、その後ReadResponseでbufioからデータを少しずつ処理(Peek)していく
- メモリに蓄えた内容をio.Readerとして読み出すバッファ
  - 基本はbytes.Bufferだけ覚えておけば良い