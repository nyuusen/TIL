# WebAPI The Good Parts

## 1章 WebAPIとは何か

- 本書でのWebAPIの定義は「HTTPプロトコルを利用してネットワーク越しに呼び出すAPI」

## 2章 エンドポイントの設計とリクエストの形式

- 良いエンドポイント設計
  - **覚えやすくどんな機能を持つURIなのかが一目で分かる**
  - 具体的には、
    - 短い
    - 人間が読める
    - 省略形は使わない
    - 大文字小文字混在させない
    - 単数系複数形、パラメータ指定方法を統一する
    - 内部のアーキテクチャを露出しない
      - URLにcgiが入っているとか
      - 内部で利用している識別子が露出しているとか
- HTTPメソッド
  - POST
    - 新しいリソースを送信する・登録する
    - 既存の更新・修正・削除はPUT・DELETEが本来は正しい
  - PUT
    - 既存リソースの完全上書き
  - PATCH
    - 既存リソースの一部を変更する
  - X-HTTP-Method-Overrideヘッダ
    - 古いブラウザや一部のライブラリなどではPATCHやDELETEなどのメソッドに対応していないケースがある
    - そういったケースに対する対応策としては、以下の2つがある
      - X-HTTP-Method-Overrideヘッダ
        - リクエスト自体はPOSTにして、X-HTTP-Method-Overrideヘッダに本来使用した値(DELETEなど)を設定する
      - _methodパラメータ
        - Formのパラメータの1つとして、application/x-www-form-urlencodedというContent typeで表されるデータの一部として送信される
          - `user=test&_method=PUT`
    - X-HTTP-Method-Overrideヘッダの方が好ましい（理由：_methodはContentTypeが限られるのと、リクエスト本文に関係のないメタ情報が入ってしまう点が微妙）
    - ちなみにX-HTTP-Method-Overrideヘッダを使用すると、一旦ブラウザからはPOSTで送信するけど、サーバー側ではDELETE等で処理を行うことを期待すると言う意味合い
      - なのでサーバー側ではこのヘッダがセットされた時の実装を考慮する必要がある
- URLとメソッド
  - `user/`: 一覧系
  - `user/:id`: 詳細系
  - 上記のエンドポイントに対して、GETなら取得、POSTなら登録、DELETEなら削除といったように、エンドポイントで「あるデータの集合」や「個々のデータ」表現し、HTTPメソッドで操作を表すのがWebAPI設計の基本中の基本となる
- URL設計に関しては少しだけ深掘りしてメモを残した: https://github.com/nyuusen/TIL/blob/f8c0a5e7b01f9d2bd9b5e9fb66f658e0e8147c2f/system-design/url-path.md
- SNSでの友達削除処理について
  - `DELETE /v1/users/:id/friends/:id`というエンドポイント例に
  - 2つ目のIDを「友達のユーザーIDにするか？」「友達関係を表す別のIDにするか？」
  - 結論、「友達のユーザーIDにする」で良い
    - 理由は、
      - エンドポイントは、「自分のユーザーID＋相手のユーザーID」でユニークになっているため、固有リソースを表すことができている
      - 友達関係IDのような新たな数値が入ってくるよりも、利用者にもわかりやすい＆扱いやすいので、エンドポイント生成も容易（Hackableを満たしている）
  - **内部のアーキテクチャの都合をAPIに反映させる必要は全くない**
- 複数の単語を繋げる場合は「-」が良い
  - Google的には「-」の方がSEOが良いらしい（APIはSEO関係ないが）
  - 「_」だと、リンク表示時の下線とかぶってしまい見づらい
  - キャメルケースだと、ホスト名は英語小文字大文字の区別がつかないことを考えると一貫性に欠ける
  - 結論、特にこだわりがないなら「-」が良い
    - それ以前に、単語を繋ぎ合わせること自体極力避けた方が良い
- ページネーション検索
  - limit/offsetもしくはper_page/pageのどちらかに統一する
  - 相対位置を指定する問題点
    - データ量が増えるとSQLパフォーマンスが悪くなる
      - なぜなら先頭からカウントしていくため
    - 更新頻度が高いデータだと、リクエスト毎の整合性が取れなくなるリスクもある
  - そこで解決するための策として「絶対位置」で指定する
    - 絶対位置というのは、このIDより後ろとかこの時間より後ろとかそういうやつ
- 絞り込み検索
  - 全文検索には「q」というパラメータ名が使われることが多々ある（`?q=hoge`）
- 検索用エンドポイントとして`search`を含めるべきか？
  - まずsearch自体は動詞でありリソースではないので、そういった観点では入れるべきではない
  - ただTwitterやInstagramのような一覧すべてを取得することが困難である場合は、検索を行うためのAPIを提供しますよという訴求のためsearchを入れるのはありだと思う
- 自分の情報へのエイリアス
  - 自分自身のユーザー情報へのアクセスするエンドポイントURLにselfやmeを使用するケースは多い
  - 自分のユーザーIDを取得してURLを生成するといったような処理をユーザー毎にしなくて良いメリットがある(フロントエンド実装的にも固定URLを置くだけで良いので実装が楽)
  - また、このように他のユーザー情報取得APIと別のAPIとすることにより、保守性や安全性が向上する
    - 自分自身の情報はより秘匿な情報を閲覧できることが多く、1つのAPIの中での分岐処理だと意図しないバグが発生しかねない
- ホスト名の設計
  - 多くのサービスはapi.twitter.comのように、apiというサブドメインにしている
  - twitter.com/apiのように、パスの第1階層をapiにしてしまうという選択肢もあるが、ホスト名に入れた方が長さ的にも合理的であり、DNSレベルで分割できるのでホスト名に入れてしまった方が良い
- LSUDsとSSKDs
  - LSUDs: Large Set of Unknown Developers
    - 大多数向けの未知の外部開発者に向けたAPI
    - ここまでの話は、このLSUDsの話
  - SSKDs: Small Set of Known Developers
    - 利用者が自分が知っている開発者向けのAPI（自分でコントロールできる人たち）
    - 1スクリーン＝1APIという言葉があり、画面の要求に合わせてAPIを設計する
      - 例えばTOPページで必要な項目（記事一覧、人気記事、人気ユーザー等）をまとめて返すAPIを1つ実装する
    - 画面側の要求に合わせてAPIを設計すると、必ずしも汎用で美しい設計にはならない
  - APIの種類？によって、設計思想が異なるという話
  - 参考: [WebAPIを作る前に考えること - LSUDsとSSKDs、オーケストレーション層 #API - Qiita](https://qiita.com/peka2/items/273be01065a921833878)
- HATEOAS
  - これは少し特殊なアプローチで、RESTへの到達を表すリチャードソンの成熟度モデルにおける、レベル3に相当するもの
  - hypermedia as the engine of application state(アプリケーション状態エンジンとしてのハイパーメディア)
  - APIで、そのリソースへのハイパーリンク（URL）を含める
  - クライアントは、そのAPIへの入口さえ知っていれば、それ以降の（詳細の）URLを知らなくて良い（普段の私たちのブラウザでのネットサーフィンと同じ）
  - メリットとしては、
    - URLを変更しやすい
      - 特に変更してから配布するまで時間がかかるモバイルアプリケーションでは有効
    - URLを改造しづらい設計にしなくて良い
      - 上では改造しやすい設計が良いといったが、主にセキュリティの観点からURLを推測されたく場合はこちらの方が良い 
      - ちなみに改造というのは、user/{user_id}のように、{user_id}の部分を変更することで、任意のリソースにアクセスしやすいみたいなことを指している
  - HATEOAS(REST LEVEL3 API)を採用するケース
    - SSKDsなら、ニーズ次第で採用の余地あり
    - だが、LSUDs（オープンに公開するAPI）では、これまでのAPIクライアントとは違った仕組みが必要であり、そもそもこの考えも世にあまり広まっていない

## 3章 レスポンスデータの設計

- プログラムで処理をしやすいデータ形式で返すというのが基本

### データフォーマット

- 今は主流はJSON
- かつてウェブ上でプログラム向けのデータをやり取りするための選択肢はXLだけだった
  - AJAXのXがXMLの頭文字であることや、JSで非同期にHTTP通信を行うオブジェクト名がXMLHttpRequestであることから、AJAXはかつてXMLを前提としていたことがわかる
- JSONが流行った理由
  - XMLよりシンプルで、同じデータを表すのにサイズが小さくて住むこと
  - ウェブの世界においてはクライアントのデフォルト言語であるJavaScriptと相性が良いこと

### データフォーマットの指定方法

- クライアントが受け取りたい形式をどのようにサーバーに伝えるか？
  - クエリパラメータ
  - リクエストするファイルを拡張子付きにする
  - Acceptというリクエストヘッダを使用する
- 意外にも、世界のサービスはクエリパラメータ指定が多い(?format=json)

### JSONP

- JSON with Padding
- Paddingは、詰め物・余計なものを意味する
- クロスサイト環境で、他のオリジンからJSONデータを取得するために考案された仕組み
- 例: `callback({"id": 123, "name": "John"})` をAPIが返す
- クライアント側はグローバル関数を用意し、APIリクエスト時にパラメータとして関数名を渡す
- サーバー側はデータと共にJavaScript関数を実行する形で返却する(`Content-Type`は`javascript`になる)
- クライアント側はJavaScript関数の中でデータアクセスやDOM操作をおこなう
- こうすることで、SOP制限にひっかからずにクロスオリジンのリソースにアクセス可能となる
  - scriptタグのsrc属性ではSOP制限がかからないので、回避できる裏技的なやり方
- セキュリティ機構であるSOPを回避する方法であり、現在はCORSという仕組みがあるので現在はJSONPの対応をする必要はない

### データの内部構造の考え方

- 利用するデータのフォーマットが決まったら、実際にどんなデータを返すかを決める
- なるべくAPIアクセス数が少なくなるように設計するのが良い
- 友達一覧APIでユーザーIDのリストを返すだけでなく、名前などの情報も返すようにする
- とは言っても、何でもかんでも返すとデータ量が大きくなってしまいそれも良くない
- 上記を回避する方法として、
  - クエリパラメータを使って、利用者が取得する項目を選択するようにする
    - 1つ1つ項目を指定するのも大変なので、パック売りみたいなイメージのレスポンスグループを設定するのも良い

### 配列とフォーマット

- トップレベルに配列？オブジェクトで包む？
  - 筆者的にはデータが何を示すかわかりやすい、他のAPIと形式を統一できるという理由でオブジェクトで包むことが好み
- APIによってオブジェクトだったり、配列だったりすると、クライアント側のレスポンスボディパース処理がちょっと面倒になる可能性
- 最大の理由としてJSONインジェクションのリスクを下げる
  - JSONインジェクションは、scriptタグで他のサービスのAPIが提供するJSONファイルを読み込ませ、その内容を不正に入手すること
  - トップレベルのオブジェクトはJavaScript的にはブロックとみなされるので、ブラウザで構文エラーが発生する
- 配列はそれ単体でJavaScript構文として成り立つためエラーは発生しない

#### 配列の件数と、続きがあるかどうかをどう返すべきか

- 全件カウントは重い処理になりがちなので、本当に必要かをしっかりと見極める必要がある
- オンラインショップの検索結果一覧画面なら件数はあった方が利便性が良いし、SNSのタイムラインなら件数表示は不要
- ページネーションで「次があるか」は、例えば1リクエストで20件の場合、サーバー側では21件を取得するようにして、21件ある場合はhasNextのような次あるよフラグを立ててあげたりすると良いと思う

### 各データのフォーマット

- 性別
  - sexとgender
  - sexは生物学的、genderは社会的・文化的
- 日付
  - RFC3399が推奨(例: `1995-12-17T03:24:00Z`)
    - 使いやすく・読みやすい。これまでの課題を解決されたWeb標準フォーマット
  - 日付に加え、曜日という冗長な情報がない
  - 年月日という構成が日本人にフレンドリー
  - APIを日本で配信しているなら+09:00を使うのも良いが、インターネットは理論上は世界と繋がっているので+00:00を使うのがおすすめ
    - UTCは、`Z`で表現することも可能
  - RFC3399は、ISO8601のサブセットである
    - ISO8601は、`1995-12-17`など形式を選ぶことができる
    - WebAPIの世界では、クライアントとサーバーという関係上、パーサーの実装がしやすく、曖昧さがないRFC3399の方が好ましい
- 大きな整数とJSON
  - 32ビット整数とその課題
    - integer: 負数ありの32ビット
      - 2の31乗(1ビットは符号用)
    - unsigned int: 正数のみの32ビット
      - 2の32乗
    - 上記はいずれも32ビットで表現されるので32ビット整数と呼ぶ
    - integerで表すことができるのは最大42億の数値を表すことができるが、Facebookなどの億単位のユーザーを抱えるサービスでは足りなくなってしまう
  - 64ビット整数
    - そこで64ビットを使う数値型: SQLならbigint、Cならuint64
    - 正の数であれば1800京まで表すことができる
    - こういった大きな数値を扱うには問題が起きうるので注意
      - 64ビット整数を32ビット整数として扱ってしまう
      - JSは数値を全てIEEE754標準の64ビット浮動小数として扱うため、大きな数字を扱うと誤差が出てしまう
        - ES2020から、任意精度倍数を扱えるBigIntが導入された（`const x = 9007199254740993n; // 「n」を末尾に付けてBigIntリテラル`）
      - 回避策としては数値型ではなく、文字列として扱うようにする

### レスポンスデータの設計

- 友達一覧もユーザー検索も、ユーザーの情報としては同じ情報を返すようにする
  - 「ユーザー情報はこういう情報です」というデータ構造にしておくと、それを処理するクライアント側は同じコードで処理できるので楽
- **APIのユースケースを考え、ユーザーが最もシンプルに扱うことができるように設計する**ことを目指す

### エラーの表現

- 「エラーになりました」だけで、何が原因だったのか？どこで発生したのか？がわからないので不親切
- まずはステータスコードでエラーを表現する
  - 成功時にしか200番を返してはならない
  - なぜなら世にある汎用ライブラリはこのステータスコードを見て結果を判別していることが多いため
- メンテナンス時は503を返し、終了予定時刻をRetry-Afterヘッダで返すと良い
  - ちなみにメンテナンス時間を短く見積もりがちなので、余裕を持ってスケジュールする（予定より短くなって怒る人はいない）
- 意図的に不正確な情報を返す
  - ブロックしているときは403ではなく404としてしまうとか

## 4章 HTTPの仕様を最大限利用する

- なるべくHTTPで定められた標準仕様に則りましょう

### HTTPステータス
- 200番台
  - 201: Created
    - サーバー側でデータが作成された
  - 202: Accepted
    - リクエスト処理が非同期で行われ、処理は受け付けたけれど完了していない場合につかう
  - 204: No Content
    - レスポンスが空
    - DELETEメソッドなどでデータの削除を行なった
    - しかし空という情報だけでは情報として足りなすぎる（DELETEなら消されたリソース情報を返すべきだ）という意見もある
  - 筆者的には、
    - PUTやPATCH: 200+操作したデータを返す
    - POST: 201
    - DELETE: 204
      - そのデータが不要だから消すのであって、その消したいデータが返ってきても有効ではないよねという意見
- 300番台 追加で処理が必要
  - 301: 恒久移動
  - 302: 一時的な移動
    - 当時はこの2つしか存在していなかった
    - これの仕様としては、元のURIに対するメソッドと同じメソッドを使用するとなっていた
    - が、多くのブラウザがリダイレクト先にGETリクエストを行うようになっていた（これを厳密にしたのが、後述の307と308）
  - という背景があり、リダイレクト先では必ずGETを行う303(See Other)と307(Temporary Redirect)が新しく作られた
  - また、307と308は302と301をより厳密にしたもので、POSTからGETへのメソッド変更を許可していない
- 400番台 クライアントのリクエストに問題あり
  - 400: BadRequest
    - その他を表す
    - 他の400番台では表現できない
  - 401: Unauthorized
    - 認証エラー
  - 403: Forbidden
    - 認可エラー
  - 404: NotFound
    - そのURIエンドポイント自体が存在しなかったのか、リソースが存在しなかったのかなど詳しい情報は伝える必要がある

### キャッシュ

- HTTPには2つのキャッシュタイプ「Expiration Model」と「Validation Model」がある
- Expiration Modelは、保存期間を決めておき、期限が切れたら再度アクセスして取得を行う
- Validation Modelは、今保持しているものが最新であるかを問い合わせて、データが更新されていた場合のみ取得を行う
- 新鮮な状態をfresh、そうでない状態をstaleと呼ぶ
- Expiration Model
  - いつ期限が切れるかをHTTPヘッダCache-ControlもしくはExpiresのどちらかでサーバー側で設定する
  - Cache-Controlは現在時刻からの秒数で、Expiresは絶対時間で表現する
  - どちらを返すかはデータの性質によりけりで、例えば毎日同じ時間に更新される天気予報は絶対時間(Expires)にすべき
  - 静的なデータなどで遠い将来の日時を指定する場合は、HTTP1.1で定められている通り、MAXで1年後にしておくべき
  - 併用した場合は、新しいCache-Controlが優先される
  - max-ageの計算には、Dateヘッダ（サーバーがレスポンスを生成した日時）が利用される
    - ちなみにこのDateヘッダは、HTTPの仕様により500番台などのいくつかを除き、必ずつけるものと定義されている
    - Goでは、net/httpのhttp.Serverを使ってレスポンスを返すとこのDateの他に、Content-LengthとContent-Typeは自動で付与される
- Validation Model
  - サーバー側は「データの更新あったらその情報をください」という条件付きリクエストに対応する必要がある
    - もし更新がなかったら304 Not Modifiedを返す必要がある
  - サーバー側は、そのデータの「最終更新日付（Last-Modified）」か「エンティティタグ（ETag,レスポンスデータのMD5キャッシュなど）」返す
  - それに対してクライアント側は、条件付きリクエストとしてIf-Modified-SinceもしくはIf-None-Matchを渡す
    - それぞれの値には、サーバーから返ってきたLast-ModifiedもしくはETagの値を入れる
  - ETagの値となるハッシュ生成にはMD5やSHA1などの（高速な）関数が利用される
- Varyでキャッシュ単位を指定する
  - URL以外にどのリクエストヘッダ項目を、データを一意に特定するために利用するかを指定する
  - 例えばVaryにAccept-Languageをセットすることで、言語を切り替えても異なる言語のキャッシュが使用されてしまうことを避けたいといったケースに対して有用
- Cache-Control
  - stale-while-revalidateは、プロキシサーバーがmax-ageで指定された時間を超えた後も、裏側で非同期にキャッシュの検証を行いつつ、キャッシュしていたレスポンスデータをレスポンスに返して良いというもの
    - 例えば、max-age=600, stale-while-revalidate=600という指定だった場合、データが新鮮なのは10分間だけだが、その後の10分間はキャッシュサーバーは保持しているキャッシュを返すことができる。その間キャッシュサーバーはリクエストとは別で非同期でオリジンサーバーへキャッシュの検証を行う問い合わせを行う
    - つまり、キャッシュの期限が切れても一旦古いキャッシュを返して良い（バックグラウンドで再検証しながら）というもの
    - これはコンテンツが少し古くても支障がないブログ記事やランキングなどで有用で、ユーザーからするとページ表示速度が速いという利点がある
    - 補足として、「非同期でオリジンサーバーへキャッシュの検証を行う問い合わせを行う」が発生する契機はユーザーからのリクエスト（つまりmax-ageを超えた最初のリクエストは必ず古いキャッシュ（データの更新があった場合）が返ることになる）
  - stale-if-errorは、オリジンサーバーへのアクセスがエラーになった時に、保持している新鮮ではないキャッシュを返して良い秒数

### メディアタイプ
