# WebAPI The Good Parts

## 1章 WebAPIとは何か

- 本書でのWebAPIの定義は「HTTPプロトコルを利用してネットワーク越しに呼び出すAPI」

## 2章 エンドポイントの設計とリクエストの形式

- 良いエンドポイント設計
  - **覚えやすくどんな機能を持つURIなのかが一目で分かる**
  - 具体的には、
    - 短い
    - 人間が読める
    - 省略形は使わない
    - 大文字小文字混在させない
    - 単数系複数形、パラメータ指定方法を統一する
    - 内部のアーキテクチャを露出しない
      - URLにcgiが入っているとか
      - 内部で利用している識別子が露出しているとか
- HTTPメソッド
  - POST
    - 新しいリソースを送信する・登録する
    - 既存の更新・修正・削除はPUT・DELETEが本来は正しい
  - PUT
    - 既存リソースの完全上書き
  - PATCH
    - 既存リソースの一部を変更する
  - X-HTTP-Method-Overrideヘッダ
    - 古いブラウザや一部のライブラリなどではPATCHやDELETEなどのメソッドに対応していないケースがある
    - そういったケースに対する対応策としては、以下の2つがある
      - X-HTTP-Method-Overrideヘッダ
        - リクエスト自体はPOSTにして、X-HTTP-Method-Overrideヘッダに本来使用した値(DELETEなど)を設定する
      - _methodパラメータ
        - Formのパラメータの1つとして、application/x-www-form-urlencodedというContent typeで表されるデータの一部として送信される
          - `user=test&_method=PUT`
    - X-HTTP-Method-Overrideヘッダの方が好ましい（理由：_methodはContentTypeが限られるのと、リクエスト本文に関係のないメタ情報が入ってしまう点が微妙）
    - ちなみにX-HTTP-Method-Overrideヘッダを使用すると、一旦ブラウザからはPOSTで送信するけど、サーバー側ではDELETE等で処理を行うことを期待すると言う意味合い
      - なのでサーバー側ではこのヘッダがセットされた時の実装を考慮する必要がある
- URLとメソッド
  - `user/`: 一覧系
  - `user/:id`: 詳細系
  - 上記のエンドポイントに対して、GETなら取得、POSTなら登録、DELETEなら削除といったように、エンドポイントで「あるデータの集合」や「個々のデータ」表現し、HTTPメソッドで操作を表すのがWebAPI設計の基本中の基本となる
- URL設計に関しては少しだけ深掘りしてメモを残した: https://github.com/nyuusen/TIL/blob/f8c0a5e7b01f9d2bd9b5e9fb66f658e0e8147c2f/system-design/url-path.md
- SNSでの友達削除処理について
  - `DELETE /v1/users/:id/friends/:id`というエンドポイント例に
  - 2つ目のIDを「友達のユーザーIDにするか？」「友達関係を表す別のIDにするか？」
  - 結論、「友達のユーザーIDにする」で良い
    - 理由は、
      - エンドポイントは、「自分のユーザーID＋相手のユーザーID」でユニークになっているため、固有リソースを表すことができている
      - 友達関係IDのような新たな数値が入ってくるよりも、利用者にもわかりやすい＆扱いやすいので、エンドポイント生成も容易（Hackableを満たしている）
  - **内部のアーキテクチャの都合をAPIに反映させる必要は全くない**
- 複数の単語を繋げる場合は「-」が良い
  - Google的には「-」の方がSEOが良いらしい（APIはSEO関係ないが）
  - 「_」だと、リンク表示時の下線とかぶってしまい見づらい
  - キャメルケースだと、ホスト名は英語小文字大文字の区別がつかないことを考えると一貫性に欠ける
  - 結論、特にこだわりがないなら「-」が良い
    - それ以前に、単語を繋ぎ合わせること自体極力避けた方が良い
- ページネーション検索
  - limit/offsetもしくはper_page/pageのどちらかに統一する
  - 相対位置を指定する問題点
    - データ量が増えるとSQLパフォーマンスが悪くなる
      - なぜなら先頭からカウントしていくため
    - 更新頻度が高いデータだと、リクエスト毎の整合性が取れなくなるリスクもある
  - そこで解決するための策として「絶対位置」で指定する
    - 絶対位置というのは、このIDより後ろとかこの時間より後ろとかそういうやつ
- 絞り込み検索
  - 全文検索には「q」というパラメータ名が使われることが多々ある（`?q=hoge`）
- 検索用エンドポイントとして`search`を含めるべきか？
  - まずsearch自体は動詞でありリソースではないので、そういった観点では入れるべきではない
  - ただTwitterやInstagramのような一覧すべてを取得することが困難である場合は、検索を行うためのAPIを提供しますよという訴求のためsearchを入れるのはありだと思う
- 自分の情報へのエイリアス
  - 自分自身のユーザー情報へのアクセスするエンドポイントURLにselfやmeを使用するケースは多い
  - 自分のユーザーIDを取得してURLを生成するといったような処理をユーザー毎にしなくて良いメリットがある(フロントエンド実装的にも固定URLを置くだけで良いので実装が楽)
  - また、このように他のユーザー情報取得APIと別のAPIとすることにより、保守性や安全性が向上する
    - 自分自身の情報はより秘匿な情報を閲覧できることが多く、1つのAPIの中での分岐処理だと意図しないバグが発生しかねない
- ホスト名の設計
  - 多くのサービスはapi.twitter.comのように、apiというサブドメインにしている
  - twitter.com/apiのように、パスの第1階層をapiにしてしまうという選択肢もあるが、ホスト名に入れた方が長さ的にも合理的であり、DNSレベルで分割できるのでホスト名に入れてしまった方が良い
- LSUDsとSSKDs
  - LSUDs: Large Set of Unknown Developers
    - 大多数向けの未知の外部開発者に向けたAPI
    - ここまでの話は、このLSUDsの話
  - SSKDs: Small Set of Known Developers
    - 利用者が自分が知っている開発者向けのAPI（自分でコントロールできる人たち）
    - 1スクリーン＝1APIという言葉があり、画面の要求に合わせてAPIを設計する
      - 例えばTOPページで必要な項目（記事一覧、人気記事、人気ユーザー等）をまとめて返すAPIを1つ実装する
    - 画面側の要求に合わせてAPIを設計すると、必ずしも汎用で美しい設計にはならない
  - APIの種類？によって、設計思想が異なるという話
  - 参考: [WebAPIを作る前に考えること - LSUDsとSSKDs、オーケストレーション層 #API - Qiita](https://qiita.com/peka2/items/273be01065a921833878)
- HATEOAS
  - これは少し特殊なアプローチで、RESTへの到達を表すリチャードソンの成熟度モデルにおける、レベル3に相当するもの
  - hypermedia as the engine of application state(アプリケーション状態エンジンとしてのハイパーメディア)
  - APIで、そのリソースへのハイパーリンク（URL）を含める
  - クライアントは、そのAPIへの入口さえ知っていれば、それ以降の（詳細の）URLを知らなくて良い（普段の私たちのブラウザでのネットサーフィンと同じ）
  - メリットとしては、
    - URLを変更しやすい
      - 特に変更してから配布するまで時間がかかるモバイルアプリケーションでは有効
    - URLを改造しづらい設計にしなくて良い
      - 上では改造しやすい設計が良いといったが、主にセキュリティの観点からURLを推測されたく場合はこちらの方が良い 
      - ちなみに改造というのは、user/{user_id}のように、{user_id}の部分を変更することで、任意のリソースにアクセスしやすいみたいなことを指している
  - HATEOAS(REST LEVEL3 API)を採用するケース
    - SSKDsなら、ニーズ次第で採用の余地あり
    - だが、LSUDs（オープンに公開するAPI）では、これまでのAPIクライアントとは違った仕組みが必要であり、そもそもこの考えも世にあまり広まっていない

## 3章 レスポンスデータの設計

- プログラムで処理をしやすいデータ形式で返すというのが基本

### データフォーマット

- 今は主流はJSON
- かつてウェブ上でプログラム向けのデータをやり取りするための選択肢はXLだけだった
  - AJAXのXがXMLの頭文字であることや、JSで非同期にHTTP通信を行うオブジェクト名がXMLHttpRequestであることから、AJAXはかつてXMLを前提としていたことがわかる
- JSONが流行った理由
  - XMLよりシンプルで、同じデータを表すのにサイズが小さくて住むこと
  - ウェブの世界においてはクライアントのデフォルト言語であるJavaScriptと相性が良いこと

### データフォーマットの指定方法

- クライアントが受け取りたい形式をどのようにサーバーに伝えるか？
  - クエリパラメータ
  - リクエストするファイルを拡張子付きにする
  - Acceptというリクエストヘッダを使用する
- 意外にも、世界のサービスはクエリパラメータ指定が多い(?format=json)

### JSONP

- JSON with Padding
- Paddingは、詰め物・余計なものを意味する
- クロスサイト環境で、他のオリジンからJSONデータを取得するために考案された仕組み
- 例: `callback({"id": 123, "name": "John"})` をAPIが返す
- クライアント側はグローバル関数を用意し、APIリクエスト時にパラメータとして関数名を渡す
- サーバー側はデータと共にJavaScript関数を実行する形で返却する(`Content-Type`は`javascript`になる)
- クライアント側はJavaScript関数の中でデータアクセスやDOM操作をおこなう
- こうすることで、SOP制限にひっかからずにクロスオリジンのリソースにアクセス可能となる
  - scriptタグのsrc属性ではSOP制限がかからないので、回避できる裏技的なやり方
- セキュリティ機構であるSOPを回避する方法であり、現在はCORSという仕組みがあるので現在はJSONPの対応をする必要はない

### データの内部構造の考え方

- 利用するデータのフォーマットが決まったら、実際にどんなデータを返すかを決める
- なるべくAPIアクセス数が少なくなるように設計するのが良い
- 友達一覧APIでユーザーIDのリストを返すだけでなく、名前などの情報も返すようにする
- とは言っても、何でもかんでも返すとデータ量が大きくなってしまいそれも良くない
- 上記を回避する方法として、
  - クエリパラメータを使って、利用者が取得する項目を選択するようにする
    - 1つ1つ項目を指定するのも大変なので、パック売りみたいなイメージのレスポンスグループを設定するのも良い

配列とフォーマット
トップレベルに配列？オブジェクトで包む？
筆者的にはデータが何を示すかわかりやすい、他のAPIと形式を統一できるという理由でオブジェクトで包むことが好み
APIによってオブジェクトだったり、配列だったりすると、クライアント側のレスポンスボディパース処理がちょっと面倒になる可能性
最大の理由としてJSONインジェクションのリスクを下げる
JSONインジェクションは、scriptタグで他のサービスのAPIが提供するJSONファイルを読み込ませ、その内容を不正に入手すること
トップレベルのオブジェクトはJavaScript的にはブロックとみなされるので、ブラウザで構文エラーが発生する
配列はそれ単体でJavaScript構文として成り立つためエラーは発生しない