# AWSコンテナ設計構築本格入門

[AWSコンテナ設計構築本格入門](https://www.nri-net.com/books/2fxup8utd3sl/)
[いまならこう作りたい AWSコンテナ[本格]入門ハンズオン　〜2024年版 ハンズオンの構想〜 - Speaker Deck](https://speakerdeck.com/horsewin/imanarakouzuo-ritai-awskontena-ben-ge-ru-men-hanzuon-2024nian-ban-hanzuonnogou-xiang)

# Chapter01 コンテナの概要

- コンテナは、他のプロセスとは隔離された状態でOS上にソフトウェアを実行する技術
  - コンテナ上で実行されたソフトウェアは単に1つのプロセスとして稼働しているのにも関わらず、**コンテナ内のソフトウェアから見ると独立したOS環境を占有している**ように見える
- サーバー仮想化は、ゲストOSごとにカーネルを占有する仕組み
- コンテナ技術は、OSとカーネルは共有し、プロセスを分離する仕組み
  - コンテナのプロセスごとに、プロセッサやメモリ等のコンピューティングリソースが割り当てられ、アプリケーション稼働に必要なライブラリやミドルウェア等の依存関係が全て含まれる

# Chapter02 コンテナの設計に必要なAWSの基礎知識

- コントロールプレーン
  - コンテナを管理する機能
  - ECSがこれにあたり、ECSはフルマネージドなコンテナオーケストレーターである(実行環境ではない)
- データプレーン
  - 実際に稼働するリソース環境
  - EC2とFargateがある

# Chapter03 コンテナを利用したAWSアーキテクチャ

- Well-Architectedフレームワークに則り、アーキテクチャを考える

## 1. 運用上の優秀性

- 以下のような観点から設計を検討する
  - どのようにシステムの状態を把握するか
  - どのように不具合の修正を容易にするか
  - どのようにデプロイのリスクを軽減するか
- モニタリングとは？
  - システム内で定めた状態を確認し続けること
  - 目的は、システムの可用性を維持するために問題発生に気づくことである
- →メモリ使用量などの定量情報である「メトリクス」や、アプリケーションの「ログ」などの定性的な情報から状態を検知し、アラートとして通知する
- ECSのようなコンテナサービスでは、小さなサービス同士が連携して動作することが多いので、障害発生時の影響範囲の把握や原因の特定が難しくなりがち
  - そこで、一連の処理内容を追えるためにするのが「トレース」
- 上記をひっくるめて、システム内部の状態を深掘りできるような状態を「オブザーバビリティ」という
  - オブザーバビリティを獲得することが、優れた運用に繋がる

### ロギング設計

- CloudWatch Logsによるログ運用
  - ECS/Fargate構成では、CloudWatch Logsと連携することで、容易にログを収集できる
    - 具体的には、タスク定義のlogConfiguration.logDriverにawslogsを設定するだけ
  - サブスクリプションフィルターを使って特定の文字列が含まれている場合のみLambdaに連携→SNSを使って通知
- FireLensによるログ運用
  - メリットは、CloudWatch Logs以外のAWSサービスやAWS外のSaaSへのログ転送がしやすい
  - ログルーティング機能を担うOSSのFluentBitなどの選択が可能
  - CloudWatch Logsへの同時転送も可能
- CloudWatch LogsとFireLensの使い分け
  - ECSタスク定義の仕様としては、コンテナごとにログ出力先を指定するログドライバーの定義は1つ
  - まず考えられるのがCloudWatch Logsを転送→S3にエクスポートする
    - CloudWatch Logsはログを取り込んだタイミングで料金が発生してしまう
  - コスト最適化と障害時運用の両立を図りたい場合は、FireLensがオススメ
    - FluentBitは、CloudWatch LogsとS3への同時ログ転送に対応している
  - 一方で、CloudWatch Logsに取り込まれたログは、クエリベースでログ検索できたり、ダッシュボード表示が可能と、一概にCloudWatch Logsへの転送を避けるべきではない
  - ログ運用で大事なのは**「ビジネス観点で、ログをどのように扱うか、ユースケースを描くこと」**である
    - ビジネス目標に対して、ログ種類や保持期間、分析方法を検討し、設計する

### メトリクス設計

- ECSで取得可能なメトリクスとして、以下が挙げられる
  - CloudWatchメトリクス
  - CloudWatch Container Insights
- 以下は、ECSクラスターまたはECSサービスの単位でデフォルトで取得できる
  - CPU使用率
  - メモリ使用率
    - それぞれ1分間隔で取得
- より詳細なメトリクスを取得するにはCloudWatch Container Insightsの有効化が必要
  - ECSタスクごとに収集可能
  - ディスクやネットワークに関するメトリクス

### トレース設計

-  trace情報の取得をサポートするサービスとして「X-Ray」がある
   - サービスマップのダッシュボードも提供されており、システム全体の可視化も可能
- ECS/FargateでX-Rayを利用する場合、以下のようなサイドカー構成となる
  - ECSタスク定義の中にアプリケーションコンテナとX-Rayコンテナを同梱する
  - アプリケーション自体にAWSが提供するX-Ray用のSDKで一部コーディングを施す
- ECS上のコンテナアプリケーションからX-Rayにトレース情報を書き込むためには特定のIAM権限が必要となる
  - 具体的には、ECSタスクロールが必要になる
  - タスク実行ロールではないことは注意（X-Rayにトレース情報を書き込む主体はECSコンテナエージェントではなく、ECSタスク＝X-Rayコンテナなので）
- VPCからパブリックネットワークへの通信経路が必要
  - X-RayはVPC外のAWSパブリックネットワーク上に存在する
  - ECSタスクがプライベートサブネットにデプロイされている場合は、X-Ray用のVPCエンドポイントかNATゲートウェイを用意する

### CI/CD設計

- コンテナはポータビリティ・再現性・軽量さという観点で、CI/CDと相性が良い
  - 開発環境・本番環境でシステム構成が異なることはよくある
    - そうなると、OSやライブラリバージョンなどビルド・デプロイ手順で意識する必要があり、手間やミスが増える
  - コンテナは、アプリケーションに必要な依存関係をパッケージ化してビルドするため、ホストマシン上で同じように振る舞う
    - なので、実行環境によらない再現性があるコンテナは、よりCI/CDとの相性が良い

### ECR

- ECRの実体はS3
- 各環境で1つのECRを利用する場合、ライフサイクルポリシーで商用環境が参照しているイメージを削除してしまうという点は注意
  - 環境ごとの固有のタグを付与し、タグごとにライフサイクルポリシーを設定する
- イメージタグはコミットIDを付与することで、どのソースコードバージョンかの判別が容易となる

### ガバナンスとコンプライアンス要件の考慮

- 以下の要件を満たす方法を考える
  - リリースに関連したファイルの改ざん防止策を考慮すること
  - 意図しないソフトウェアリリースを防ぐ目的として、承認プロセスを設けること
  - 規定されたCI/CDパイプライン以外のリリースを禁止すること
- まず、リリースに関連したファイルの配置先は以下になる
  - ステージ間でアーティファクトを受け渡すS3バケット
  - コンテナイメージを保管するECR
- 検討できる方法としては、
  - S3バケットを操作するユーザーのポリシーとバケットポリシー等による制限
  - CodePipeline上で承認プロセスを設置
    - GitHubActionsでも可能
  - ECSやECRに書き込み・実行権限を設け、CI/CDパイプラインを介さないコンテナイメージデプロイを禁止

## 2.セキュリティ

- 「責任共有モデル」を理解することで、どのようなセキュリティ対策を行うべきかが見えてくる
- ECR、Trivy(OSS)によるイメージの脆弱性スキャン
  - 継続的にスキャンすることが大事
- dockleなどのチェックツールを利用する
- 提供元が信頼できるベースイメージを利用する
- GuardDutyで、外部と不正な通信がないかをチェックする
- 秘密情報は、SecretsManagerやSSMパラメータストアに格納し、環境変数としてコンテナ内に安全に秘密情報を挿入する
  - 環境変数名に対し、値としてARNを設定するだけ
  - 注意点として、SSMパラメータストアにはstringとsecure string定義が存在し、secure stringは内部的にKMSで暗号化されて、暗号・復号されるが、stringは暗号化されないので注意

### レジストリに対する対策

- ライフサイクルを適切に設定し、古いイメージは削除する運用にする
  - 古いイメージは脆弱性混入しがちであり、そのイメージが誤ってデプロイされてしまうことを避ける
- 同名タグをプッシュされた時に上書きされないようにIMMUTABLE設定をする
- 特定のIAMユーザー/ロールからしかアクセスできないようプライベートレジストリにする
  - そもそもパブリックレジストリを作成できないようにIAMポリシーを作成できるので、SCPに適用し、Organizationsの組織内でそのポリシーを継承・適用するのがオススメ
- イメージプッシュは、CIからのみ許可するポリシー設定をする

### オーケストレータ(ECS)に対する対策

- IAMグループにポリシーを割り当て、ECSの操作スコープを制限する
- ECSのネットワークセキュリティはVPC全体を俯瞰して考える
  - ECS/Fargateで起動するECSタスクは全てVPC上に配置される
  - タスクに関するネットワーク接続方法はいくつかあり、「ネットワークモード」と呼ばれる
  - Fargate上にホストされる場合は、awsvpcというネットワークモードが選択され、独自のENIが割り当てられ、そこにIPv4アドレスが割り当てられることで、ECSタスクが独立したネットワークサービスとして捉えることができる

### コンテナに対する対策

- コンテナからの無制限ネットワークアクセスへの対策
  - ECSタスクから構成されるVPCネットワークには次の3つが設計ポイントになる
    - パブリックネットワーク→VPCの通信
      - WAF - ALB - ECSの構成で、ECSはプライベートサブネットに配置する
    - ECSタスク間の通信
      - 例えば、FEのECSタスクとBEのECSタスクがどちらもプライベートサブネットに配置されている例
      - BEのECSタスクのセキュリティグループのインバウンドルールとして、FEのECSタスクのセキュリティグループを設定すると、到達できる送信元を制御できる
    - VPC→パブリックネットワークの通信
      - パブリックサブネットにNATゲートウェイを配置して、ECSはプライベートサブネットに配置する
      - AWSリソースへの通信はVPCエンドポイントにする
        - VPCエンドポイントのインターフェース型は時間料金と処理データ量に応じた課金が発生する
        - 仮にCloudWatch LogsのVPCエンドポイントをマルチAZに配置した場合は2,700円ほど
        - NATゲートウェイをマルチAZに配置した場合は12,000円
          - VPCエンドポイントはサービスごとに配置する必要があるので、コスト圧縮の観点でNATゲートウェイに軍配が上がることもある点は注意
        - ECRをVPCエンドポイント接続する場合は、ECRに加えてS3のVPCエンドポイントも必要になる(ECRの実態はS3であるため)
- アプリケーションの脆弱性への対策
  - タスク定義でルートファイルシステムアクセスを読み取り専用にする
    - ファイル改竄に関する脅威を小さくできる

## 3.信頼性

- 障害復旧やスケールなど
- マルチAZ構成による可用性向上
  - Fargateを使用すると、ECSサービス内部のスケジューラがベストエフォートでAZ間の負荷バランスを調整しながらタスク配置してくれる
- CloudWatchメトリクスを使用してタスクの障害を検知
- ECSサービスを利用してタスクを自動復旧
- ALBを利用して、ターゲットECSタスクが障害した時に切り離す

### メンテナンスによるECSタスク停止への対処

- コントロールプレーンからECSタスクに対して停止状態を指示された際のハンドリングに関しても考慮が必要
- ECSは、AWS内部におけるハードウェア障害やセキュリティ脆弱性が存在するプラットフォームであると判断された場合、新しいECSタスクに置き換えるイベントを発生させる
- Fargate上で稼働しているECSタスクについては、必要なパッチ運用や内部のインフラストラクチャ更新に伴いメンテナンスイベントが発生する
- 処理の整合性を求められるビジネスでは、停止指示がなされた場合に、適切にアプリケーションをハンドリングする必要がある
- ECSではタスク停止を指示する際、ECSクラスターがタスクに対してSIGTERMシグナルを送信する
  - このシグナルに応答がない場合、デフォルト30秒でタイムアウトし、その後SIGKILLシグナルが発行される
    - ただし、タイムアウトするまでの時間はタスク定義パラメータで変更可能
- ECSで動かすアプリケーションにおいては、SIGTERMシグナルを受信したら、アプリケーションが安全に終了するように実装しましょう

### システムメンテナンス時におけるサービス停止

- ALBのリスナールールで、ESCタスクが登録されているターゲットグループへの転送ルールと固定レスポンス(503とか)を返却する転送ルールを用意する

## パフォーマンス設計

- FargateではOSレイヤの管理は不要となるが、コンピューティングリソースのサイジング等の設定は必要

### 適切なリソース設計の流れ

- まずはビジネス上のパフォーマンス要件（性能要件）を把握する
  - ただし、AWSを利用する場合は、必要に応じてリソースを容易にスケールできるので、厳密に見積もる必要はない
  - とは言いつつ、ある程度は利用者数やワークロードの特性を見極めつつ、性能目標から必要なリソースを仮決めするのは重要
- AutoScalingを活用する

### STEP1: ビジネス上のパフォーマンス要件

- 具体的な数値の要件(10リクエスト/秒)から、必要なタスクのリソースやタスク数を検討する
- ピーク時のアクセスを考慮し、スパイクを擬似的に発生するテストや挙動(エラーが発生せず処理継続が可能)を確認するよう計画する

### STEP2-1: リソースの割り当て

- 初期のタイミングである程度余裕を持つのが良い
- ただし、タスク定義に割り当てたCPU・メモリサイズ分の料金が発生するので、余剰なリソースは避けた方が良いのは言うまでもない
- まずは単体でアプリケーションを稼働させてみて、その後のステップでテスト結果などをふまえ、コストとのバランスを見極めて設定を行う

### STEP2-2: スケール戦略の検討

- スケールアップとスケールアウトでスケールアウトが良い理由
  - 停止が不要
  - スケールアップには上限がある
  - AutoScalingでスケール判断の自動化が簡単
  - パフォーマンス効率だけでなく、可用性と耐障害性が向上する
- AutoScalingを活用する
  - CloudWatchアラームで定めたメトリクスの閾値にしたがってスケールアウトやスケールインが実行される
- スケーリングポリシー
  - ステップスケーリングポリシー
    - スケールアウト/インする条件にステップを設けることで段階的にスケールアクションを設定できるポリシー
    - 例えば、タスクの平均CPU使用率が60%でタスクを数を10%追加するみたいな
  - ターゲット追跡スケーリングポリシー
    - 指定したメトリクスのターゲット値を維持するようにスケールアウト/インが制御されるポリシー
    - AWS側が自動でタスク量を調整してくれるので、よりマネージドな戦略であり、管理も楽になる
    - スケールアウトは高速に動作するが、スケールインは緩やかな実行される
  - どちらが良いのか？
    - 筆者の推奨は「ターゲット追跡スケーリングポリシー」
    - 理由：チューニング不要である点・コスパのバランスが良い

### STEP3: テストの実施

- ツールを活用し、実際に想定されるリクエスト量を流して以下の観点でテストする
  - メトリクスが取得できているか
  - エラーログ出ていないか
  - ログ内容は適切か(欠損等やログレベルの妥当性)
  - スケールイン/アウトができているか

### STEP4: メトリクスの確認

- STEP3のテストを実行しつつ、CloudWatchメトリクスを活用して以下を確認する
  - パフォーマンス要件で定義したリクエスト量が満たされているか
  - ECSタスクおよびコンテナに割り当てたCPU/メモリに余剰や逼迫が生じていないか
  - AutoScalingのスケールアウト・インは正しく発動するか
  - スケールアウト・イン時にエラーログが吐かれていないか

### STEP5: リソース割り当てやスケール戦略の見直し

- STEP4の結果から、ECSタスク定義のリソース割り当てやスケール戦略の閾値を調整する

### パフォーマンス設計に必要なマインドセット

- 必要なメトリクスを収集し、適切なサイジングを行うことは重要

## コスト最適化設計

- まずは必要十分なリソース量を定めることが基本動作
- Compute Saving Plansの活用
  - 1年or3年のいずれかの期間を指定リソースの利用をコミットすることで割引される
- コンテナイメージのメンテナンス
  - イメージサイズに比例して料金が発生するため
- 非商用環境のタスク稼働時間帯の調整
  - 必要な時間帯を整理し、EventBridge Schedulerで定期的に起動・停止を行う
- Fargate Spotの活用
  - 停止を許容できる環境で活用する
  - 60-70%削減

# Chapter04 コンテナを構築する(基礎編)

# Chapter05 コンテナを構築する(実践編)

