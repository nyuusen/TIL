# 試して理解 Linuxのしくみ

# 第1章 Linuxの概要

## プログラムとプロセス

- Linuxではさまざまなプログラム（一連の命令）が動いている
  - コンパイラ言語ではビルド後の実行ファイルがプログラムで、スクリプト言語ではソースコードそのものがプログラムとなる
  - そしてカーネルもプログラムの1種
- マシンの電源を入れるとまずカーネルが起動する。それ以外のすべてのプログラムはカーネルの後に起動する。
- 起動後に動作中のプログラムのことを「プロセス」という（広義にはこれもプログラムと呼ぶこともある）

## カーネル

- カーネルとは何か？なぜ必要か？というのをプロセスがストレージデバイスに直接アクセスできるシステムを例に考えてみる
- 例えばある異なる別のプロセスの実行順序が制御されず、意図しない領域へのアクセスができてしまうと問題になる
- このような問題に対処するのが、（ハードウェアの力を借りた）カーネルである
- 一般的なPCやサーバーのCPUには、カーネルモードとユーザーモードという2つのモードがある
- Linuxでは、カーネル（モード）のみがデバイスにアクセスできる
- それに対して、プロセスはユーザーモードで動作するため、デバイスにアクセスできないので、カーネルを介して間接的にデバイスにアクセスする
- まとめると
  - カーネルは、システム内の全てのプロセスが共有するリソースを一元管理して、システム上のプロセスに配分する
  - そのために、カーネルモードで動作するプログラムが「カーネル」なのである

## システムコール

- システムコールとは、プロセスがカーネルに処理を依頼するための方法
  - プロセスやメモリ、通信、ファイルシステムやデバイス管理あたり
- プロセスはユーザーモードで動いているが、システムコールを発行すると、CPUにおいて例外イベントが発生する
  - これをきっかけに**CPUのモードがユーザーモードからカーネルモードに遷移**し、依頼内容に応じたカーネルの処理が動作する
  - この動作が終わると、再びユーザーモードに戻ってプロセス本体の動作を継続する
- システムコールの冒頭で、プロセスからカーネルへの要求が正当なものかをチェックする（保有している量を超えるメモリが要求されていないかなど）
- システムコール以外で、プロセスからCPUのモードを変更する方法はない（もしあったら任意の悪意あるプロセスから攻撃できてしまう）
- システムコール発行の可視化
  - Goでhello worldを出力するプログラムを書き、straceコマンドでシステムコールを確認
  - 自分の環境では`write(1, "Hello, World!\n", 14)`と出力されていた
    - このwriteがシステムコールにあたるもの
  - カーネルに処理を依頼する時は、システムコールを発行することを確認できた
- システムコールしている時間の割合
  - sarコマンドで論理CPUの処理割合を確認
  - 親プロセスのプロセスIDを取得するループ処理を実行し、CPUがユーザーモード・カーネルモードがそれぞれのモードで動いていることを数値で確認できた
  - この辺りのシステムの統計情報は、システムが想定通りに動いているかを把握するために非常に重要
    - これを人間やるのが辛いので、ZabbixやDatadogなどのツールを用いて、正常状態を定義し、異常になった際に通知するアラート機能と合わせて使用することが多い
    - また併せて、数値の羅列では可視性が良くないので、ダッシュボード（上記のツールに包含されていることが多い）もよく使われる

## ライブラリ

- 標準Cライブラリ
  - C言語にはISOによって定められた標準ライブラリがある（Linuxでもこの標準Cライブラリが提供されている）
  - 通常はGNUプロジェクトが提供するglibcを標準Cライブラリとして使用する（単にlibcと表記されることが多い）
  - libcは、ユーザースペース用のライブラリ
    - printf、malloc、fopen、write など、アプリケーションが便利に使える関数を提供している
- そもそも標準Cライブラリってなぜ必要？何をする？
  - ほとんどのプログラムがlibcを内部的に利用している（高級言語たちのランタイムも同様）
  - LinuxのようなUNIX系OSでは、ユーザープログラムとカーネルの間を取り持つ役目としてlibcが使われる
  - libcは各ユーザーモードで動いているプロセスから、ファイル書き込みや標準出力などの処理依頼を受けて、内部的にシステムコールを発している
  - つまりlibcはカーネルとのインターフェイス層みたいなもの
    - そもそもカーネル本体がほぼC言語で書かれている
- `ldd /bin/echo`でechoコマンドがどのようなライブラリをリンクしているかを確認
  - `libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6`という結果から、内部的にlibcを利用して動いていることがわかる
  - catもpython3コマンドでも同様
  - 普段C言語を触ることは少ないが、OSレベルでは縁の下の力持ちとして重要な言語であることがわかる

### 一旦ここまでまとめ

- ユーザープロセスがechoなどの処理を実行する
- echoの処理は内部的にlibcが提供する関数を実行する(write())
- write()が実行されると、内部でアセンブリを用いてsyscall命令が実行され、カーネルに処理を依頼
- カーネルが標準出力を行う

#### ライブラリを「リンクする」という表現について

これも気になったのでちょっと調べた。

- C言語はコンパイルすると.oファイルが出来上がる
- その中で外部ライブラリの関数を使っていた場合、コンパイラは「この関数が必要です」と記録するが、中身は含めない
- その後のリンクという工程で、ライブラリの関数本体と繋げる＝リンクする必要がある
- .oファイルは中間ファイルであり、リンク処理が行われることで.oから.outファイルができ上がる（.outは実行ファイル）

#### なぜCPUモードを分ける必要があるのか？

全部カーネルモードで動ければ、システムコール発行してCPUモード切り替えてという必要がなくなるのでは？と思ったので調べてみた
→結論、セキュリティ・安全性を守るために、CPUモードを分けている

- OSカーネルは、全プロセスの情報・全メモリ・全デバイスにアクセスできる
- もし普通のアプリケーション（ユーザープログラム）がカーネルと同じように動けてしまったら、他人の情報を盗んだり、OSクラッシュも可能になってしまう

### システムコールのラッパー関数

- libcは標準Cライブラリだけではなく、システムコールのラッパー関数というものを提供している
- システムコールは、通常の関数呼び出しとは異なり、C言語などの高級言語から直接呼び出すことはできず、代わりにアーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
- ユーザープログラムからは、各言語に対して容易されているシステムコールのラッパー関数を呼び出すだけで済む

### 静的ライブラリと共有ライブラリ

- ライブラリは2種類ある
  - 静的ライブラリ: リンク時にライブラリ内の関数をプログラムに組み込む
  - 共有ライブラリ: リンク時にこのライブラリ内の関数を呼び出すといった情報だけを実行ファイルに埋め込む
- 以下の理由で共有ライブラリが多く使われてきた
  - システム全体としてサイズを小さくできる
  - ライブラリに問題があった際に共有ライブラリを書き換えるだけでOK
- 静的リンクの復権
  - 理由として、
    - メモリやストレージの大容量化
    - プログラムが1つのファイルだけで動けば、そのファイルをコピーするだけで別の環境でも動くので扱いが楽
    - 実行時に共有ライブラリをリンクしなくて良いので起動が高速
    - 共有ライブラリのDLL地獄（互換性がなくなった時のプログラムが動作しない問題）を回避
  - Goは基本的にライブラリを全て静的リンクしている
  - Goがシングルバイナリで実行できるのはこれが理由

### 各言語(ランタイム)とlibcの関係性

気になったので調べた。

#### Go

- 通常Goプログラムはlibcを使わない
- システムコールを使う場合は、Goのランタイムまたは標準ライブラリが直接syscallを発行している
- ただし、CGOを使った場合は、GoプログラムからC言語ライブラリを使うようになり、libcが必要となる

#### Node

- 内部的にC/C++で書かれたネイティブコード(libuvなど)を含み、これらがOSに対してシステムコールを発行する際にlibcを使用する

```
JavaScript コード
↓
Node.js 実行環境
 ├ V8エンジン（GoogleのJSエンジン）
 ├ libuv（I/O処理・非同期など）
 ├ C/C++コード（Nodeの本体部分）
 ↓
 libc.so → システムコール → Linuxカーネル
```

### カーネル・システムコールのまとめ

- デバイス制御等を行うにはカーネルモードで動作するCPUが処理をする必要がある
  - デバイスI/Oはハードウェアへのアクセスを含むため、特権命令が必要→カーネルモードでしか実行できない
- カーネルモードで動作するCPUに処理を依頼するにはシステムコールの発行が必要
- システムコールの発行にはlibcのラッパー関数を呼び出す必要がある
  - もしくはlibcを使わなくても、Goプログラムのように直接アセンブリ等で発行可能
  - アセンブリは、低級言語であり、より低レベルな形で記述する必要がある
- 例えばNode.jsプログラムが動いている（プロセス）とした場合、Nodeランタイムに含まれるlibuvからlibc関数を実行→システムコール発行→デバイス制御等を行うという流れ

# 第2章 プロセス管理（基礎編）

- 新しくプロセスを生成する目的は「同じプログラムの処理を複数のプロセスに分けて処理する（Webサーバーの複数リクエスト受付）」と「別のプログラムを生成する」
- 同じプロセスを生成するのは以下の流れで、libcの中でsyscallラッパー関数のfork()が実行される
  - 親プロセスがfork()を呼ぶ
  - CPUがカーネルモード切り替わる（システムコール発行）
  - カーネルがプロセスの複製を行う