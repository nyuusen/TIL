# 試して理解 Linuxのしくみ

# 第1章 Linuxの概要

## プログラムとプロセス

- Linuxではさまざまなプログラム（一連の命令）が動いている
  - コンパイラ言語ではビルド後の実行ファイルがプログラムで、スクリプト言語ではソースコードそのものがプログラムとなる
  - そしてカーネルもプログラムの1種
- マシンの電源を入れるとまずカーネルが起動する。それ以外のすべてのプログラムはカーネルの後に起動する。
- 起動後に動作中のプログラムのことを「プロセス」という（広義にはこれもプログラムと呼ぶこともある）

## カーネル

- カーネルとは何か？なぜ必要か？というのをプロセスがストレージデバイスに直接アクセスできるシステムを例に考えてみる
- 例えばある異なる別のプロセスの実行順序が制御されず、意図しない領域へのアクセスができてしまうと問題になる
- このような問題に対処するのが、（ハードウェアの力を借りた）カーネルである
- 一般的なPCやサーバーのCPUには、カーネルモードとユーザーモードという2つのモードがある
- Linuxでは、カーネル（モード）のみがデバイスにアクセスできる
- それに対して、プロセスはユーザーモードで動作するため、デバイスにアクセスできないので、カーネルを介して間接的にデバイスにアクセスする
- まとめると
  - カーネルは、システム内の全てのプロセスが共有するリソースを一元管理して、システム上のプロセスに配分する
  - そのために、カーネルモードで動作するプログラムが「カーネル」なのである

## システムコール

- システムコールとは、プロセスがカーネルに処理を依頼するための方法
  - プロセスやメモリ、通信、ファイルシステムやデバイス管理あたり
- プロセスはユーザーモードで動いているが、システムコールを発行すると、CPUにおいて例外イベントが発生する
  - これをきっかけに**CPUのモードがユーザーモードからカーネルモードに遷移**し、依頼内容に応じたカーネルの処理が動作する
  - この動作が終わると、再びユーザーモードに戻ってプロセス本体の動作を継続する
- システムコールの冒頭で、プロセスからカーネルへの要求が正当なものかをチェックする（保有している量を超えるメモリが要求されていないかなど）
- システムコール以外で、プロセスからCPUのモードを変更する方法はない（もしあったら任意の悪意あるプロセスから攻撃できてしまう）
- システムコール発行の可視化
  - Goでhello worldを出力するプログラムを書き、straceコマンドでシステムコールを確認
  - 自分の環境では`write(1, "Hello, World!\n", 14)`と出力されていた
    - このwriteがシステムコールにあたるもの
  - カーネルに処理を依頼する時は、システムコールを発行することを確認できた
- システムコールしている時間の割合
  - sarコマンドで論理CPUの処理割合を確認
  - 親プロセスのプロセスIDを取得するループ処理を実行し、CPUがユーザーモード・カーネルモードがそれぞれのモードで動いていることを数値で確認できた
  - この辺りのシステムの統計情報は、システムが想定通りに動いているかを把握するために非常に重要
    - これを人間やるのが辛いので、ZabbixやDatadogなどのツールを用いて、正常状態を定義し、異常になった際に通知するアラート機能と合わせて使用することが多い
    - また併せて、数値の羅列では可視性が良くないので、ダッシュボード（上記のツールに包含されていることが多い）もよく使われる

## ライブラリ

- 標準Cライブラリ
  - C言語にはISOによって定められた標準ライブラリがある（Linuxでもこの標準Cライブラリが提供されている）
  - 通常はGNUプロジェクトが提供するglibcを標準Cライブラリとして使用する（単にlibcと表記されることが多い）
  - libcは、ユーザースペース用のライブラリ
    - printf、malloc、fopen、write など、アプリケーションが便利に使える関数を提供している
- そもそも標準Cライブラリってなぜ必要？何をする？
  - ほとんどのプログラムがlibcを内部的に利用している（高級言語たちのランタイムも同様）
  - LinuxのようなUNIX系OSでは、ユーザープログラムとカーネルの間を取り持つ役目としてlibcが使われる
  - libcは各ユーザーモードで動いているプロセスから、ファイル書き込みや標準出力などの処理依頼を受けて、内部的にシステムコールを発している
  - つまりlibcはカーネルとのインターフェイス層みたいなもの
    - そもそもカーネル本体がほぼC言語で書かれている
- `ldd /bin/echo`でechoコマンドがどのようなライブラリをリンクしているかを確認
  - `libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6`という結果から、内部的にlibcを利用して動いていることがわかる
  - catもpython3コマンドでも同様
  - 普段C言語を触ることは少ないが、OSレベルでは縁の下の力持ちとして重要な言語であることがわかる

### 一旦ここまでまとめ

- ユーザープロセスがechoなどの処理を実行する
- echoの処理は内部的にlibcが提供する関数を実行する(write())
- write()が実行されると、内部でアセンブリを用いてsyscall命令が実行され、カーネルに処理を依頼
- カーネルが標準出力を行う

#### ライブラリを「リンクする」という表現について

これも気になったのでちょっと調べた。

- C言語はコンパイルすると.oファイルが出来上がる
- その中で外部ライブラリの関数を使っていた場合、コンパイラは「この関数が必要です」と記録するが、中身は含めない
- その後のリンクという工程で、ライブラリの関数本体と繋げる＝リンクする必要がある
- .oファイルは中間ファイルであり、リンク処理が行われることで.oから.outファイルができ上がる（.outは実行ファイル）

#### なぜCPUモードを分ける必要があるのか？

全部カーネルモードで動ければ、システムコール発行してCPUモード切り替えてという必要がなくなるのでは？と思ったので調べてみた
→結論、セキュリティ・安全性を守るために、CPUモードを分けている

- OSカーネルは、全プロセスの情報・全メモリ・全デバイスにアクセスできる
- もし普通のアプリケーション（ユーザープログラム）がカーネルと同じように動けてしまったら、他人の情報を盗んだり、OSクラッシュも可能になってしまう

### システムコールのラッパー関数

- libcは標準Cライブラリだけではなく、システムコールのラッパー関数というものを提供している
- システムコールは、通常の関数呼び出しとは異なり、C言語などの高級言語から直接呼び出すことはできず、代わりにアーキテクチャ依存のアセンブリコードを使って呼び出す必要がある
- ユーザープログラムからは、各言語に対して容易されているシステムコールのラッパー関数を呼び出すだけで済む

### 静的ライブラリと共有ライブラリ

- ライブラリは2種類ある
  - 静的ライブラリ: リンク時にライブラリ内の関数をプログラムに組み込む
  - 共有ライブラリ: リンク時にこのライブラリ内の関数を呼び出すといった情報だけを実行ファイルに埋め込む
- 以下の理由で共有ライブラリが多く使われてきた
  - システム全体としてサイズを小さくできる
  - ライブラリに問題があった際に共有ライブラリを書き換えるだけでOK
- 静的リンクの復権
  - 理由として、
    - メモリやストレージの大容量化
    - プログラムが1つのファイルだけで動けば、そのファイルをコピーするだけで別の環境でも動くので扱いが楽
    - 実行時に共有ライブラリをリンクしなくて良いので起動が高速
    - 共有ライブラリのDLL地獄（互換性がなくなった時のプログラムが動作しない問題）を回避
  - Goは基本的にライブラリを全て静的リンクしている
  - Goがシングルバイナリで実行できるのはこれが理由

### 各言語(ランタイム)とlibcの関係性

気になったので調べた。

#### Go

- 通常Goプログラムはlibcを使わない
- システムコールを使う場合は、Goのランタイムまたは標準ライブラリが直接syscallを発行している
- ただし、CGOを使った場合は、GoプログラムからC言語ライブラリを使うようになり、libcが必要となる

#### Node

- 内部的にC/C++で書かれたネイティブコード(libuvなど)を含み、これらがOSに対してシステムコールを発行する際にlibcを使用する

```
JavaScript コード
↓
Node.js 実行環境
 ├ V8エンジン（GoogleのJSエンジン）
 ├ libuv（I/O処理・非同期など）
 ├ C/C++コード（Nodeの本体部分）
 ↓
 libc.so → システムコール → Linuxカーネル
```

### カーネル・システムコールのまとめ

- デバイス制御等を行うにはカーネルモードで動作するCPUが処理をする必要がある
  - デバイスI/Oはハードウェアへのアクセスを含むため、特権命令が必要→カーネルモードでしか実行できない
- カーネルモードで動作するCPUに処理を依頼するにはシステムコールの発行が必要
- システムコールの発行にはlibcのラッパー関数を呼び出す必要がある
  - もしくはlibcを使わなくても、Goプログラムのように直接アセンブリ等で発行可能
  - アセンブリは、低級言語であり、より低レベルな形で記述する必要がある
- 例えばNode.jsプログラムが動いている（プロセス）とした場合、Nodeランタイムに含まれるlibuvからlibc関数を実行→システムコール発行→デバイス制御等を行うという流れ

# 第2章 プロセス管理（基礎編）

- 新しくプロセスを生成する目的は「同じプログラムの処理を複数のプロセスに分けて処理する（Webサーバーの複数リクエスト受付）」と「別のプログラムを生成する」
- 同じプロセスを生成するのは以下の流れで、libcの中でsyscallラッパー関数のfork()が実行される
  - 親プロセスがfork()を呼ぶ
  - CPUがカーネルモード切り替わる（システムコール発行）
  - カーネルがプロセスの複製を行う
- 同じプロセスの生成とは...？
  - 身の回りでよくあるのが「シェルコマンド実行」と「サーバーが複数のリクエストを捌く時」
  - シェルコマンド実行の例では、
    - 親プロセスとしてbashなどが常駐している
    - ユーザーがコマンドを実行すると、親プロセスが子プロセスを作る
    - なぜこのようなことをするのかというと、次のコマンド入力を受け付けできるようにしておくため

### シグナル

- あるプロセスから他のプロセスに何かを通知して、外部から実行の流れを強制的に変えるための仕組み
- よく使われるのがctrl + CのSIGINT
  - SIGINTを受け取ったプロセスは、デフォルトでは終了する
  - シグナルハンドラという処理をあらかじめ登録しておくことで無視したりすることができる
- SIGKILL
  - 絶対プロセス殺すマン
  - シグナルハンドラによる挙動変更はできない

### デーモン

- デーモンは常駐プロセスであり、システムの開始から終了まで存在し続ける
- 端末が割り当てられていない＝ログインセッションなどと結び付かずにバックグラウンドで動く

# 第5章 プロセス管理(応用編)

- 複数のプログラムが強調動作するために、各プロセスがデータを共有したりする機能は、OSが「プロセス間通信」として提供している
- Linuxでは、目的別にたくさんのプロセス間の通信を提供されており、その一部を紹介する

### 共有メモリ

- mmapシステムコールを使用する
- 複数プロセスで同じファイルを同じメモリアドレスにマップすれば共有メモリとして使える
- ポインタを共有する

### シグナル

- SIGINTなどのシグナルもプロセス間通信の1つ
- POSIXでは、SIGUSR1とSIGUSR2という、プログラマが自由に用途を決めて良いシグナルがある
- ただしシグナルは原始的な仕組みなので、送信先にシグナルが届いたという情報しか送れず、データを受け渡すには別の方法を検討する必要がある

### パイプ

- パイプを介して複数のプロセス間通信が可能

### マルチプロセスとマルチスレッド

- CPUのマルチコア化によって、プログラムの並列動作の重要性が高まっている
- 並列動作させるには「別のことをする複数のプログラムを同時に動かすこと」と「ある目的を持った1つのプログラムを複数の流れに分割して実行すること」
- このセクションでは後者の「ある目的を持った1つのプログラムを複数の流れに分割して実行すること」を説明していく
- この方法を実現するには「マルチプロセス」と「マルチスレッド」がある
- マルチプロセス: 上で説明したfork関数などを使って必要なだけプロセスを生成し、それぞれがプロセス間通信によってやり取りしながら処理していく
- マルチスレッド: プロセス内に複数の流れを作る
- マルチスレッドの長所
  - ページテーブルのコピーが不要なため、生成時間が短い
  - 様々なリソースをスレッド間で共有するため、メモリをはじめリソース消費量が少ない
  - 全スレッド間でメモリを共有するため、見かけ上の協調動作がしやすい
- マルチスレッドの短所
  - 1つのスレッドの障害が、全スレッドに影響する
    - 1つのスレッドが不正なアドレスを参照して異常終了した場合、プロセス全体が異常終了する
  - 各スレッドが実行する処理がマルチスレッドプログラムから呼び出して良いかを熟知しておく必要がある
    - グルーバル変数を排他制御なしにアクセスしている場合はスレッドセーフではない
- マルチスレッドプログラムを期待通りに作るのは大変なのでマルチスレッド化の恩恵を受けながら、プログラミングを簡単にする様々な方法が存在する
  - 例えばGoのgoroutineは、言語の組み込み機能によってスレッドの扱いを簡単にしている

### マルチプロセス・スレッドについてもう少し深掘り

- マルチプロセス
  - プロセス: OSが管理する実行中のプログラムの単位（メモリ空間を独立して持つ）
  - プロセス間で通信するには、パイプ・ソケット・共有メモリなどが必要
  - 1つのプロセスが落ちても他に影響しにくい
  - メリット
    - 安定性が高い
    - 障害が局所化しやすい
    - マルチコアCPUを最大限に活かしやすい
  - デメリット
    - プロセス生成や通信のオーバヘッドが大きい
    - メモリ共有が難しい（非効率）
- マルチスレッド
  - スレッド: プロセスの中の処理の流れ
  - マルチスレッドは、1つのプロセス内に複数のスレッドを作り、それぞれが並行に処理する方式
  - スレッドは同じメモリ空間を共有する
  - スレッド間通信がメモリ経由で行えるので簡単
  - goroutineなど、言語ごとに実装が用意されている
  - メリット
    - メモリ共有なので通信が高速
    - スレッド生成が軽量で高速
  - デメリット
    - 共有メモリの競合によるバグ（レースコンディション）が発生しやすい
    - 1つのスレッドがクラッシュすると、プロセス全体が落ちることがある
- 「マルチスレッドを自作するのは難しい」という件
  - 難しいポイント
    - スレッド生成・破棄などの管理（OSに依頼）
    - ロックなどの制御
    - デッドロックや競合状態への対処
    - スレッドごとのスタック管理
  - なのでgoroutineのように言語側の仕組みとして用意している
- goroutine
  - 軽量な仮想スレッド（※OSスレッドではない）
  - GoランタイムがOSスレッドを数本確保していて、goroutineをスケジュールしている
  - ユーザーはスレッドプールやロックなどを意識せずに並行処理できる
  - goroutineは仮想CPUにキューされて、仮想CPUが空いているOSスレッドにgoroutineをアサインする流れ
- スケジューラとは？
  - 複数の実行単位（スレッド・タスク）をどのCPUコアでいつ実行するかを決める制御機構のこと

# 第6章 デバイスアクセス

- プロセスはデバイスに直接アクセスできない
- 代わりにカーネルに代行してもらう
  - 具体的には、デバイスファイルという特殊なファイルがインターフェイスとなって操作を行う
- プロセスがデバイスファイルを操作すると、カーネルの中のデバイスドライバというソフトウェアが、ユーザの代わりにデバイスにアクセスする
- デバイスファイルは、`/dev/`配下にある
  - `console  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  urandom  zero`

# 第7章 ファイルシステム

- 各種デバイスはデバイスファイルを介してアクセスできるが、ストレージデバイスはほとんどファイルシステムを介してアクセスする