# 試して理解 Linuxのしくみ

# 第1章 Linuxの概要

## プログラムとプロセス

- Linuxではさまざまなプログラム（一連の命令）が動いている
  - コンパイラ言語ではビルド後の実行ファイルがプログラムで、スクリプト言語ではソースコードそのものがプログラムとなる
  - そしてカーネルもプログラムの1種
- マシンの電源を入れるとまずカーネルが起動する。それ以外のすべてのプログラムはカーネルの後に起動する。
- 起動後に動作中のプログラムのことを「プロセス」という（広義にはこれもプログラムと呼ぶこともある）

## カーネル

- カーネルとは何か？なぜ必要か？というのをプロセスがストレージデバイスに直接アクセスできるシステムを例に考えてみる
- 例えばある異なる別のプロセスの実行順序が制御されず、意図しない領域へのアクセスができてしまうと問題になる
- このような問題に対処するのが、（ハードウェアの力を借りた）カーネルである
- 一般的なPCやサーバーのCPUには、カーネルモードとユーザーモードという2つのモードがある
- Linuxでは、カーネル（モード）のみがデバイスにアクセスできる
- それに対して、プロセスはユーザーモードで動作するため、デバイスにアクセスできないので、カーネルを介して間接的にデバイスにアクセスする
- まとめると
  - カーネルは、システム内の全てのプロセスが共有するリソースを一元管理して、システム上のプロセスに配分する
  - そのために、カーネルモードで動作するプログラムが「カーネル」なのである

## システムコール

- システムコールとは、プロセスがカーネルに処理を依頼するための方法
  - プロセスやメモリ、通信、ファイルシステムやデバイス管理あたり
- プロセスはユーザーモードで動いているが、システムコールを発行すると、CPUにおいて例外イベントが発生する
  - これをきっかけに**CPUのモードがユーザーモードからカーネルモードに遷移**し、依頼内容に応じたカーネルの処理が動作する
  - この動作が終わると、再びユーザーモードに戻ってプロセス本体の動作を継続する
- システムコールの冒頭で、プロセスからカーネルへの要求が正当なものかをチェックする（保有している量を超えるメモリが要求されていないかなど）
- システムコール以外で、プロセスからCPUのモードを変更する方法はない（もしあったら任意の悪意あるプロセスから攻撃できてしまう）
- システムコール発行の可視化
  - Goでhello worldを出力するプログラムを書き、straceコマンドでシステムコールを確認
  - 自分の環境では`write(1, "Hello, World!\n", 14)`と出力されていた
    - このwriteがシステムコールにあたるもの
  - カーネルに処理を依頼する時は、システムコールを発行することを確認できた
- システムコールしている時間の割合
  - sarコマンドで論理CPUの処理割合を確認
  - 親プロセスのプロセスIDを取得するループ処理を実行し、CPUがユーザーモード・カーネルモードがそれぞれのモードで動いていることを数値で確認できた
  - この辺りのシステムの統計情報は、システムが想定通りに動いているかを把握するために非常に重要
    - これを人間やるのが辛いので、ZabbixやDatadogなどのツールを用いて、正常状態を定義し、異常になった際に通知するアラート機能と合わせて使用することが多い
    - また併せて、数値の羅列では可視性が良くないので、ダッシュボード（上記のツールに包含されていることが多い）もよく使われる

## ライブラリ

- 標準Cライブラリ
  - C言語にはISOによって定められた標準ライブラリがある（Linuxでもこの標準Cライブラリが提供されている）
  - 通常はGNUプロジェクトが提供するglibcを標準Cライブラリとして使用する（単にlibcと表記されることが多い）
- そもそも標準Cライブラリってなぜ必要？何をする？
  - ほとんどのプログラムがlibcを内部的に利用している（高級言語たちのランタイムも同様）
  - LinuxのようなUNIX系OSでは、ユーザープログラムとカーネルの間を取り持つ役目としてlibcが使われる
  - libcは各ユーザーモードで動いているプロセスから、ファイル書き込みや標準出力などの処理依頼を受けて、内部的にシステムコールを発している
  - まぁつまりlibcはカーネルとのインターフェイス層みたいなもの
  - そもそもカーネル本体がほぼC言語で書かれている