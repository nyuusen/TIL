# AWSクラウドネイティブデザインパターン

[AWSクラウドネイティブデザインパターン](https://direct.gihyo.jp/view/item/000000003465)

## はじめに

- アプリケーション変更頻度と品質は正の相関にある
  - 変更頻度が低いと品質が低下する
- クラウドネイティブの定義
  - クラウドの機能を活用して運用を効率化し、高度な回復力と可観測性を実現する
  - 結果として、障害やメンテ・アクセス急増などの日々の運用に工数をかける必要がなく、頻繁に自信を持ってアプリケーションを変更できる
- これを実現するためのプラクティスと設計パターンを「運用を効率化」「回復力」「可観測性」の2つの観点から紹介するのが本書である
- クラウドネイティブを実現するには「疎結合」が重要な概念
  - 疎結合なアーキテクチャとは「コントロール可能な部品を明確に定義されたインターフェイスで組み合わせるアーキテクチャ」のこと
  - インターフェイスのみ知っておけば、コンポーネント間を繋いでシステムを構築できる
  - これに役立つ技術がコンテナやサーバーレスになる
  - 「コントロール可能」とは、望む動作を得られたりするように、管理できているということ

# 第1部 運用を効率化する

## 1.責任共有モデルを意識してアーキテクチャを選択する

- 責任範囲の最小化
  - 責任共有モデルを意識して、なるべく多くの運用をクラウドに移譲する
- 責任範囲のサポート
  - 利用者が担う責任をサポートする機能やサービスを使い倒す
    - [VPC Reachability Analyzer](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html)でネットワークが目的通り設定されているかの確認が可能
    - AmazonInspectorで不要なネットワークパスが公開されていないかをスキャン
- 一言でまとめると..
  - **なるべくできるだけクラウド側に運用を任せられるアーキテクチャを選定しようぜ**

## 2.テスト容易性を高める

- テスト容易性とは、アプリケーションに対してどれだけ簡単に、かつ効果的にテストができるかという性質
- クラウドネイティブアプリケーションでは、ユニットテストを充実させることが有用
  - ユニットテストは、自動化が容易で実行が高速だから
- テストがないコード＝レガシーコードであり、レガシーコードは簡潔にいうと「密結合」なコード
- とは言っても、テストがあれば良いのかというとそうでもなく、「高い信頼性」と「開発者主体で作成されていること」が効果的である
  - テストの信頼性とは？
    - 通ればリリースできるし、通らなければリリースできない
    - 同じテストなのに実行するたびに変わるのは、偽陽性が多くなり、開発デリバリーに悪影響
    - こうした問題には、依存関係を整理してユニットテストの比重を増やすのももちろん、そもそもそう言ったテストを削除してしまうのも良い
  -  開発者主体で作成された自動テストとは？
    - 外部に発注したテストもデリバリーに良い効果を齎せない
    - 開発者主体で行うからこそ、疎結合に作り、パフォーマンス向上が見込める

### テストピラミッドとCI/CD

- 「開発者に素早くフィードバックを返す環境が重要」という観点から有名な考え方がテストピラミッド
  - テスト戦略全体において、大部分（70％くらい）をユニットテストが占めるべきというもの
  - ユニットテストは低コストで自動化が容易と定義されている
  - 詳細：[第5回 テストピラミッド～自動テストの信頼性を中長期的に保つ最適なバランス～](https://gihyo.jp/dev/serial/01/savanna-letter/0005)
- CI/CDの原則は、各ステージで失敗したらすぐに開発を止めて、原因を突き止め、修正すべきとされている
  - テストピラミッドが崩れている（ユニットテストが少ないとか）とこの原則が形骸しがちなので注意
- 一言でまとめると..
  - **とりあえずユニットテストを書いて自動化して、CI/CDパイプラインで検知しようぜ**

### テスト容易性を高めるアーキテクチャパターン

#### 依存関係の逆転

- 例えば、イベント作成メソッドの内部に「メールで通知する」という実装が含まれている例
  - このメソッドのユニットテストを書こうとすると、メールで通知するという外部に依存する処理を書く必要がある
  - そこで、通知を送るというインターフェイスを用意して、インターフェイスという抽象に依存させることで、ユニットテストではこの部分をモック化するだけで良くなるので、テストがしやすくなる
- このように依存の向きを呼び出しの向きを逆にする＝イベント作成サービス側がインターフェイスを定義して、そのインターフェイスにメール送信処理が依存すること
- この原則は、上位と下位のレイヤ構造になっている依存関係全般に適用できる
  - 特に、メールや外部API、SaaSなど、アプリケーションで直接制御していない外部との連携部分で利用すると有用である

#### コンテナによる依存関係の注入

- Dockerを使用してデータベース等の環境を立ち上げてそこでテストする
- Testcontainersでテストコードから、コンテナを起動可能

#### コマンドとクエリの分離(CQS)

- コードのメソッドをコマンドとクエリのどちらかに分離すべきという原則
- 副作用が発生するコードを局所化し、テストの容易性を向上できる
  - ユニットテストで何をテストすべきか明確になるため

#### コマンドとクエリの責任分離(CQRS)

- CQSを発展させたもので、コマンドの責務を持つクラスとクエリの責務を持つクラスを分離するデザインパターン
- 例えば、ユーザーがどのチケットを買い、どのイベントに参加したか等のアクティビティをレポートする機能があるとする
  - シンプルに実装した場合、レポート機能メソッドで様々なクラスを呼び出して情報を集めることになる
  - こうなると多くのクラスに依存し、テストが容易ではない
  - ここでアクティビティを取得するクラスにクエリの責務を分離する(CQRS)
    - その中で実際のクエリを直接書くようにする
    - UserActivityRepositoryみたいなイメージ
  - 結果として、アクティビティの依存関係がシンプルになり、テストが容易になる

- この章を一言にまとめると..
  - **とりあえず疎結合に作って、ユニットテストしやすいようにDIとCQR(S)を意識し、CI/CDパイプラインをきちんと整備しよう**

## 3.小規模かつ可逆的な変更を頻繁に行う

- クラウドネイティブなアプリケーションでは、様々な変更を、頻繁に、自信を持って行うことができる
- そのため小規模かつ可逆的な変更を積み重ねることが重要
  - いつでもロールバックできる小さな変更であれば頻繁に、自信を持って行うことができるだろう

### 継続的インテグレーション

- CI/CDの目的は、開発に集中できる状況を作ること
- ブランチ戦略の話
  - 継続的にインテグレーションされた状態を維持するには、長命なブランチを最小限に抑える必要がある
  - 例えば、開発環境ブランチ・本番環境用ブランチのように、いくつも長命なブランチが増えると、リリースのプロセスは複雑になり、それぞれのコードベースのマージにかかる不具合や工数も増えてしまう

#### トランクベース開発

- 上記の考え方に沿って、長命なブランチ＝トランクを1つに限定する開発手法がある
  - 全ての開発をトランク上で行い、ブランチの利用は短命のものにする
- クラウドネイティブにおける「小規模かつ可逆的な変更を頻繁に行う」ためには、必須と言って良いほど重要(そもそも前提みたいなもの)
- 長命なブランチを多く活用することで、継続的インテグレーションが難しくなる理由
  - リリースの安全性が損なわれる
    - 長命ブランチが増えれば増えるほどマージにかかる工数やコンフリクトへの対処が発生する
    - また、Aブランチで改修したHoge関数を、Bブランチが改修前の状態のHoge関数を実行する箇所を追加したみたいな例だと不整合も発生する
  - リファクタリングが難しくなり、技術負債が積み上がる
    - リファクタリングすることにより、不整合が発生するということは、心理的にリファクタリングをしたくなる環境ではなくなる

### 継続的インテグレーションに必要なプラクティス

- トランクベース開発は非常に重要ではあるが、実際に導入するには以下のようなプラクティスが必要
  - 信頼できる高速な自動テスト