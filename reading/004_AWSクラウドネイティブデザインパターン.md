# AWSクラウドネイティブデザインパターン

[AWSクラウドネイティブデザインパターン](https://direct.gihyo.jp/view/item/000000003465)

## はじめに

- アプリケーション変更頻度と品質は正の相関にある
  - 変更頻度が低いと品質が低下する
- クラウドネイティブの定義
  - クラウドの機能を活用して運用を効率化し、高度な回復力と可観測性を実現する
  - 結果として、障害やメンテ・アクセス急増などの日々の運用に工数をかける必要がなく、頻繁に自信を持ってアプリケーションを変更できる
- これを実現するためのプラクティスと設計パターンを「運用を効率化」「回復力」「可観測性」の2つの観点から紹介するのが本書である
- クラウドネイティブを実現するには「疎結合」が重要な概念
  - 疎結合なアーキテクチャとは「コントロール可能な部品を明確に定義されたインターフェイスで組み合わせるアーキテクチャ」のこと
  - インターフェイスのみ知っておけば、コンポーネント間を繋いでシステムを構築できる
  - これに役立つ技術がコンテナやサーバーレスになる
  - 「コントロール可能」とは、望む動作を得られたりするように、管理できているということ

# 第1部 運用を効率化する

## 1.責任共有モデルを意識してアーキテクチャを選択する

- 責任範囲の最小化
  - 責任共有モデルを意識して、なるべく多くの運用をクラウドに移譲する
- 責任範囲のサポート
  - 利用者が担う責任をサポートする機能やサービスを使い倒す
    - [VPC Reachability Analyzer](https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html)でネットワークが目的通り設定されているかの確認が可能
    - AmazonInspectorで不要なネットワークパスが公開されていないかをスキャン
- 一言でまとめると..
  - **なるべくできるだけクラウド側に運用を任せられるアーキテクチャを選定しようぜ**

## 2.テスト容易性を高める

- テスト容易性とは、アプリケーションに対してどれだけ簡単に、かつ効果的にテストができるかという性質
- クラウドネイティブアプリケーションでは、ユニットテストを充実させることが有用
  - ユニットテストは、自動化が容易で実行が高速だから
- テストがないコード＝レガシーコードであり、レガシーコードは簡潔にいうと「密結合」なコード
- とは言っても、テストがあれば良いのかというとそうでもなく、「高い信頼性」と「開発者主体で作成されていること」が効果的である
  - テストの信頼性とは？
    - 通ればリリースできるし、通らなければリリースできない
    - 同じテストなのに実行するたびに変わるのは、偽陽性が多くなり、開発デリバリーに悪影響
    - こうした問題には、依存関係を整理してユニットテストの比重を増やすのももちろん、そもそもそう言ったテストを削除してしまうのも良い
  -  開発者主体で作成された自動テストとは？
    - 外部に発注したテストもデリバリーに良い効果を齎せない
    - 開発者主体で行うからこそ、疎結合に作り、パフォーマンス向上が見込める

### テストピラミッドとCI/CD

- 「開発者に素早くフィードバックを返す環境が重要」という観点から有名な考え方がテストピラミッド
  - テスト戦略全体において、大部分（70％くらい）をユニットテストが占めるべきというもの
  - ユニットテストは低コストで自動化が容易と定義されている
  - 詳細：[第5回 テストピラミッド～自動テストの信頼性を中長期的に保つ最適なバランス～](https://gihyo.jp/dev/serial/01/savanna-letter/0005)
- CI/CDの原則は、各ステージで失敗したらすぐに開発を止めて、原因を突き止め、修正すべきとされている
  - テストピラミッドが崩れている（ユニットテストが少ないとか）とこの原則が形骸しがちなので注意
- 一言でまとめると..
  - **とりあえずユニットテストを書いて自動化して、CI/CDパイプラインで検知しようぜ**

### テスト容易性を高めるアーキテクチャパターン

#### 依存関係の逆転

- 例えば、イベント作成メソッドの内部に「メールで通知する」という実装が含まれている例
  - このメソッドのユニットテストを書こうとすると、メールで通知するという外部に依存する処理を書く必要がある
  - そこで、通知を送るというインターフェイスを用意して、インターフェイスという抽象に依存させることで、ユニットテストではこの部分をモック化するだけで良くなるので、テストがしやすくなる
- このように依存の向きを呼び出しの向きを逆にする＝イベント作成サービス側がインターフェイスを定義して、そのインターフェイスにメール送信処理が依存すること
- この原則は、上位と下位のレイヤ構造になっている依存関係全般に適用できる
  - 特に、メールや外部API、SaaSなど、アプリケーションで直接制御していない外部との連携部分で利用すると有用である

#### コンテナによる依存関係の注入

- Dockerを使用してデータベース等の環境を立ち上げてそこでテストする
- Testcontainersでテストコードから、コンテナを起動可能

#### コマンドとクエリの分離(CQS)

- コードのメソッドをコマンドとクエリのどちらかに分離すべきという原則
- 副作用が発生するコードを局所化し、テストの容易性を向上できる
  - ユニットテストで何をテストすべきか明確になるため

#### コマンドとクエリの責任分離(CQRS)

- CQSを発展させたもので、コマンドの責務を持つクラスとクエリの責務を持つクラスを分離するデザインパターン
- 例えば、ユーザーがどのチケットを買い、どのイベントに参加したか等のアクティビティをレポートする機能があるとする
  - シンプルに実装した場合、レポート機能メソッドで様々なクラスを呼び出して情報を集めることになる
  - こうなると多くのクラスに依存し、テストが容易ではない
  - ここでアクティビティを取得するクラスにクエリの責務を分離する(CQRS)
    - その中で実際のクエリを直接書くようにする
    - UserActivityRepositoryみたいなイメージ
  - 結果として、アクティビティの依存関係がシンプルになり、テストが容易になる

- この章を一言にまとめると..
  - **とりあえず疎結合に作って、ユニットテストしやすいようにDIとCQR(S)を意識し、CI/CDパイプラインをきちんと整備しよう**

## 3.小規模かつ可逆的な変更を頻繁に行う

- クラウドネイティブなアプリケーションでは、様々な変更を、頻繁に、自信を持って行うことができる
- そのため小規模かつ可逆的な変更を積み重ねることが重要
  - いつでもロールバックできる小さな変更であれば頻繁に、自信を持って行うことができるだろう

### 継続的インテグレーション

- CI/CDの目的は、**開発に集中できる状況を作る**こと
- ブランチ戦略の話
  - 継続的にインテグレーションされた状態を維持するには、長命なブランチを最小限に抑える必要がある
  - 例えば、開発環境ブランチ・本番環境用ブランチのように、いくつも長命なブランチが増えると、リリースのプロセスは複雑になり、それぞれのコードベースのマージにかかる不具合や工数も増えてしまう

#### トランクベース開発

- 上記の考え方に沿って、長命なブランチ＝トランクを1つに限定する開発手法がある
  - 全ての開発をトランク上で行い、ブランチの利用は短命のものにする
- クラウドネイティブにおける「小規模かつ可逆的な変更を頻繁に行う」ためには、必須と言って良いほど重要(そもそも前提みたいなもの)
- 長命なブランチを多く活用することで、継続的インテグレーションが難しくなる理由
  - リリースの安全性が損なわれる
    - 長命ブランチが増えれば増えるほどマージにかかる工数やコンフリクトへの対処が発生する
    - また、Aブランチで改修したHoge関数を、Bブランチが改修前の状態のHoge関数を実行する箇所を追加したみたいな例だと不整合も発生する
  - リファクタリングが難しくなり、技術負債が積み上がる
    - リファクタリングすることにより、不整合が発生するということは、心理的にリファクタリングをしたくなる環境ではなくなる

### 継続的インテグレーションに必要なプラクティス

- トランクベース開発は非常に重要ではあるが、実際に導入するには以下のようなプラクティスが必要

#### 1.信頼できる高速な自動テスト

- 継続的インテグレーションの重要なプラクティスに「検証が失敗したら即開発を止めて修正する」というものがある
  - 「常に動く状態を保ち続ける」のが原則であるため
- ただ、トランクベースの開発ではない場合、デプロイされる直前までビルドエラーとかが放置されがち
- 一方、トランクベースの開発の場合は、ある程度これが強制される
  - チェックインしたコードがすぐにデプロイされたり、他の開発者に共有されたりするので、壊れたビルドの影響範囲が大きいため
- また、毎度トランクにコードをマージする時に長いプロセスは実行できないので「高速」であることも大事
- テストの高速化と信頼性向上のための具体的なプラクティス
  - マニュアルテストや結合テストを減らし、ユニットテストの割合を増やす
  - ユニットテストが外部に依存しているようならモックに置き換える
  - 開発者が手元の環境で気軽に検証できるようにする
  - テスト実行する環境を、実行の度に新しい環境(コンテナ)を利用する（並列実行を可能にする）

#### 2.小さいチャンクでの機能開発

- トランクベースの開発では、個々の変更の独立性も重要
  - 別のブランチでの改修が依存関係にあると、トランクの頻繁な更新ができなくなってしまう
- この観点で参考にできるのが「INVEST」という考え方
  - 良いプロダクトバックログアイテム(PBI)を作るための基準になるもの
  - 小さく、独立性があり、テスト可能であることが大事
  - 小さな単位でコード変更を行い、リリースできる状態を保ちながらマージを続ける

#### 3.デプロイとリリースの分離

- いつ、どのようにリリースするかというのは複雑な要件が入り乱れていることがある
  - プレスリリースやベータ版とか
- この時にコードがマージされたらすぐにリリースされるのを避けるため、featureブランチにコードを退避したりする
  - この状態は健全ではない
- 複雑なリリース要件を満たしながら、継続的インテグレーションを実施するには、デプロイとリリースを分離する必要がある
- そこで利用される技術が「Continuous Configuration(CC)」になる
- Continuous Configuration(CC)
  - 機能フラグを用いて、リリースしたいコードを制御する
- リリースブランチ
  - メインのブランチが高品質に保たれていても、実際のリリースプロセスに時間を要することがある
    - 例：専任チームによる検証が必須とか
  - リリースブランチを導入することで、継続的インテグレーションを導入しつつ、リリースの安定化のための時間を確保できる
  - 開発チームはトランクベースで開発しつつ、リリースプロセスはリリースブランチで運用するイメージ
- 継続的デリバリー
  - そもそも継続的デリバリーとは？
    - コード変更が発生すると、自動的に実稼働環境へのリリース準備が実行されるもの
  - これを実現するためには、トランクベース開発と継続的インテグレーションを前提にコードベースを信頼できる状態に保ち、デプロイを安全に行えるようにする必要がある

#### ここまで一言でまとめると..
- トランクベースで小さく開発を進め、ユニットテストを充実＆高速化＆自動化し、CI/CDパイプラインを構築(活用)して、分離されたデプロイ＆リリースプロセスを高速に回していこう

### 小規模かつ可逆的な変更を頻繁に行うためのアーキテクチャパターン

#### Continuous Configuration(CC)によるリリース管理

- Amazonのプライムデーでは、開催と同時にコードを変更しているわけではなく、AppConfigを用いて動的にアプリケーションの挙動を変更している
- AppConfigを利用すると、機能フラグの動的な設定を実現できる
- AppConfigの仕組み
  - 公式のエージェントが用意されている
  - それをアプリケーションサーバーに導入する
  - キャッシュやポーリング間隔を設定する
  - アプリケーションからは、ローカルで動いているエージェントから値を取得するだけ(なのでパフォーマンスにも影響なさそう)
- 少しずつデプロイするクライアントを増やしていくなどのデプロイ戦略も可能
- ただし、機能フラグはロジックに余計なif文が混ざり可読性を落としてしまうのと、フラグの誤操作により障害発生などのリスクもある
  - なので、短期的なフラグとしてマーク（コードコメント等）して、定期的にクリーンアップするのが大事
  - 機能フラグを追加した時点で、削除するというバックログも追加するなどの工夫をする


#### 抽象化によるブランチ

- 機能フラグと同様に、時間のかかる変更を小さなチャンクで実施する技法の1つ
- 機能フラグは新規機能等では有用であるが、例えばORマッパを変更したいなどの既存機能に大きく影響する箇所はどうすれば良いか
- そこで活躍するのが「抽象化によるブランチ」にある
- 例えば、メール送信機能を同期処理からSQS*Lambdaの非同期処理にしたいケース
  - 実装を特定し、
  - その実装を含む抽象化レイヤを作成する
  - 既存実装を抽象化レイヤの呼び出しに変更する
  - 抽象化レイヤで機能フラグを用いて、一部を新しい実装に切り替える
  - これを完全に置き換えるまで少しづつ続ける
- つまり、
  - 呼び出し側は抽象化されたインターフェイスを呼び出すだけ  
  - そのインターフェイスの実装側で機能フラグにより新旧処理を呼び分ける
- このパターンはステップが多く開発オーバーヘッドがかかるので、呼び出し箇所が多いPRマッパの変更や基盤技術の変更等で有用

## 4.セキュリティを作り込む

### 責任共有モデルとセキュリティ

- セキュリティにおいても、最も重要なことは責任共有モデルを意識すること
- なるべくクラウド提供者の責任範囲を大きくするようにアーキテクチャを選択することで、セキュリティ対策にかける時間とコストを抑えることが重要

### 疎結合なアプリケーションのセキュリティ

- コンポーネントの中のセキュリティを考え、そしてコンポーネント間のセキュリティ（どのようなデータが送受信され、どのような権限が設定されているか）を考える
- LambdaとSQSを用いたイベント駆動アプリケーションの例
  - それぞれのリソースにアクセスできるリソースを権限で絞る
  - Lambda関数のコードをセキュリティを考える
    - Amazon Inspectorで脆弱性がないかスキャンしたり、コードに署名することで改竄されていないことを保証したりできる
- 全体を俯瞰しながら、どの部分にどのようなセキュリティ対策が必要かを体系的に実施できるのが「脅威モデリング」と呼ばれる手法

### 脅威モデリング

- 対象のシステムにどのような悪いことが起き、どのように対処すべきを明確にするための構造化された手法
- AWSでは、脅威モデリングの実施を、セキュリティに関するベストプラクティスの1つとして紹介している
- 実施頻度
  - 新規の設計や既存の設計変更など定期的に
  - 設計段階から、セキュリティ上の課題を特定できるのが大きなメリット

## 5.DevOpsとプラットフォームエンジニアリング

- DevOpsは、開発チームと運用チームが責任を共有しコラボレーションできる文化

### クラウドネイティブなチームモデル

- クラウドネイティブな開発で求められるチーム
  - 価値のあるサービスの設計〜開発〜デプロイ〜運用まで関わるビジネスのドメインに関わるチーム
  - そのチームの負荷を軽減するためのチーム
- (個人メモ)よくプロダクト開発チームとプラットフォーム/イネイブルチームみたいな構成があるが、これがそれを体現しているもの
  - このチーム構成で運用している開発組織はDevOpsを意識している（できているかはともかく）と理解できる

### プラットフォームエンジニアリング

