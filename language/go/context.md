# Context

## 基本

- プロセス間を横断する必要のあるリクエストスコープ値を伝達する

## データ構造

- context.WithValueを呼び出すと、古いContextをラップした新しい構造体がスタック or ヒープに生成され、連結リストのような構造で遡れるようになっている
- context.WithValueを呼び出すと、内部ではvalueCtxという構造体インスタンスが生成される
    ```
      type valueCtx struct {
          Context                 // 親Contextへの参照（埋め込み）
          key, val any            // 保存したいキーと値
      }
    ```
- ctx.Value(key)を実行してkeyを探すときは、現在のctx(valueCtx)からkeyが一致するかを比較し、一致しない場合は親ノードを辿っていく
- 計算量は、O(n)となる（値が埋め込まれた回数をnとする）
  - 単方向連結リストを逆方向に辿るので、何でもかんでもContextに取り出すと値の取り出し＝ルックアップの性能が線形に悪化する

## キーの衝突を避ける

- contextのキーにはstringではなく空の構造体を使用することで異なるパッケージ間で同じ文字列のキーを使って上書きしてしまうことを避ける
- keyの型はanyであり、Goにおけるany同士の比較(==)では、型ポインタとデータポインタ（または値そのもの）の両方が一致するかを判定する
- じゃあ空の構造体ではなくstringベースのカスタム型で良いのではないか？
  - 結論良いがベストではない
  - struct{}はメモリサイズが0（stringは内部にポインタと長さを保つため16バイトを消費する）
  - stringベースだと、キャストして値を覗き見ることができるが、一方で後悔しない型の構造体を使うと、絶対にそのキーにアクセスできなくなる