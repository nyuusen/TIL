# Context

## Contextの存在意義

- プロセス間を横断する必要のあるリクエストスコープ値を伝達する
  - main関数で動くメインゴルーチンはリクエストが来るたびに新しいゴルーチンを起動
  - そのまたサブルーチンから新たなゴルーチンが起動されるというのが繰り返されると木構造的に増加する
  - このように処理がいくつものゴルーチンにまたがると情報伝達に煩わしさが生じる
- チャネルを引数で渡す形でもこの課題を解決できるが、ライブラリの中で暗黙的に起動するゴルーチンには渡せないや型が決まっている制約がある
- ゴルーチン上で起動される関数の第一引数に、context.Context型を

## データ構造

- context.WithValueを呼び出すと、古いContextをラップした新しい構造体がスタック or ヒープに生成され、連結リストのような構造で遡れるようになっている
- context.WithValueを呼び出すと、内部ではvalueCtxという構造体インスタンスが生成される
  ```
  type valueCtx struct {
      Context                 // 親Contextへの参照（埋め込み）
      key, val any            // 保存したいキーと値
  }
  ```
- ctx.Value(key)を実行してkeyを探すときは、現在のctx(valueCtx)からkeyが一致するかを比較し、一致しない場合は親ノードを辿っていく
- 計算量は、O(n)となる（値が埋め込まれた回数をnとする）
  - 単方向連結リストを逆方向に辿るので、何でもかんでもContextに取り出すと値の取り出し＝ルックアップの性能が線形に悪化する

## キーの衝突を避ける

- contextのキーにはstringではなく空の構造体を使用することで異なるパッケージ間で同じ文字列のキーを使って上書きしてしまうことを避ける
- keyの型はanyであり、Goにおけるany同士の比較(==)では、型ポインタとデータポインタ（または値そのもの）の両方が一致するかを判定する
- じゃあ空の構造体ではなくstringベースのカスタム型で良いのではないか？
  - 結論良いがベストではない
  - struct{}はメモリサイズが0（stringは内部にポインタと長さを保つため16バイトを消費する）
  - stringベースだと、キャストして値を覗き見ることができるが、一方で後悔しない型の構造体を使うと、絶対にそのキーにアクセスできなくなる
