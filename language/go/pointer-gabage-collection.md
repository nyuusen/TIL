# ポインタとガベージコレクション

## はじめに

Goで関数の戻り値としてポインタを返しすぎると、ガベージコレクション(GC)も負担が増えるという問題について調べたのでメモする

## スタックとヒープ

まずは前提として、スタックとヒープを理解する必要がある。\
プログラムがデータを保存するメモリ領域として、スタックとヒープというものが存在する。

### スタック

- 関数の中で宣言された一時的なローカル変数が保存される場所
- 関数が終わると自動的に消えるので、管理が簡単で高速
- 小さいデータはスタックに置かれることが多い

### ヒープ

- プログラムのどこからでもアクセスできるデータを保存する場所
- プログラムが明示的に消すまでメモリに残る
  - それ故に不要なデータが増えるとメモリを圧迫する
- ポインタで管理されるデータはヒープに保存されることが多い
  - 関数のスコープを超えて存続する可能性があるデータであるため

## GCの必要性

- 上で述べたが「ヒープに確保されたデータは明示的に消さない限り残り続ける」という問題を解決するための仕組み
- 具体的には、GCが動いて、不要なデータを自動的に回収する
  - 不要なデータを回収するから「ガベージコレクション」という
- GCにより、開発者が手動でメモリを解放しなくても、安全にメモリ管理が可能となる
- 一方、GCが頻繁に動くと、プログラムの動作が遅くなることがある

## ポインタを返しすぎるとGCの負担が増える問題まとめ

- ポインタで管理されるデータヒープに保存される(ことが多い)
- ヒープのデータは自動的には消されないので、GCという仕組みにより、不要なデータが回収される
- つまりポインタを使いすぎるとその分GCが動くので、それにより処理が遅くなるといった問題が発生する可能性がある

## 余談: GCはどのようにして、いつ動いているのか？

- どのように動く？
  - バックグラウンドで走り続け、不要なメモリを検出すると解放する
- いつ動く？
  - 自動的に適切なタイミングで実行される
  - 手動実行も可能(`runtime.GC()`)
- 発展
  - GCが動くと不要なメモリが解放される一方、CPU使用率が一時的に上がってしまう可能性がある
  - そのため、GCの回数を減らす工夫として、小さい構造体なら値で返したり等でスタックを活用するということが考えられる
