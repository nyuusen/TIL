# I/O

## ファイル

- File構造体は以下のようになっている
  ```
    type File struct {
  	  *file // os specific
    }
  ```
- これはGoでよくみられる埋め込み（Embedding）というテクニックで継承に近い
- 利用者側からは抽象化されたメソッド（例：Write）で呼び出すことができ、その内部の処理は非公開型に隠蔽されている
  - 例えばファイル書き込み処理をしたい場合、ファイル構造体を作った後にWriteメソッドを呼ぶだけで、OSの違い（LinuxとWindowsなど）を意識する必要がなくて済む

## ネットワーク

- Linuxの思想である"everything-is-a-file"という名の通り、ネットワークに関してもファイルのように取り扱うことができる
  - そのように抽象化されているので、Goから見ると内部的にはやっていることは似たようなものになる
- サーバー側もクライアント側も結局やっていることはシステムコールを発行して、ファイルディスクリプタを取得し、Goの構造体(`net.TCPConn`構造体など)でラップしているだけ
- コネクションからデータを読み取るReadメソッドは、内部的にはreadシステムコールを発行しているだけ（Writeにおいても同じようなことが言える）

## ioパッケージによる抽象化

- io.Reader/Writerとして抽象化されていることで入力先・出力先がファイルか？ネットワークか？を意識することなく実装が可能
  - `Read(p []byte) (n int, err error)`は、渡されたバケツ（`[]byte`）にデータを詰めるという共通の振る舞いを定義している

## bufioパッケージ

- bufioパッケージはbuffered I/Oをやるためのもの
- bufio.Readerは、io.Reader型から作ることができる（`func NewReader(rd io.Reader) *Reader`）
  - io.Reader型なので、ファイル・ネットワーク等のI/Oから、buffered I/Oが作成可能
  - io.Readerのラッパーである
    ```
    type Reader struct {
      buf  []byte
      rd   io.Reader // ← ここに「生のReader（ファイルなど）」を持っている
      // ...
    }
    ```
- Readメソッドの内部挙動
  - 例えば4KBのファイルデータを小さな読み込みを繰り返す場合、
    - io.Reader: 100バイトずつ40回読み込むような、100バイト読み取るたびにシステムコールが発生する
    - bufio.Reader: 1回目のシステムコールで背後にbuf（メモリ上の倉庫）に置いておく
- Scannerメソッド
  - トークン（単語や行など）ごとに読み取りが可能（Readは指定したバイト列の長さごと）


## io vs bufio

- bufio(Buffered I/O)の方が高速
  - 書き込みの際、メモリ上のバッファにためて、バッファがいっぱいになるor明示的に指示された時に溜まったデータをまとめて書き込むため
    - 小さいデータの書き込みの度に毎度ファイルへの書き込みをしていたら、
  - 肝となるのは、システムコールの回数を削減しパフォーマンスやリソース効率を上げること
- ただし以下の例外あり
  - 既にデータが大きい場合：一度に大きな塊を書き込むなら、メモリ間のコピーが無駄なステップを増やすだけ
  - リアルタイム性が必要な場合：バッファが溜まっている間にプログラムがクラッシュするとまだ書き出されていないデータが消える
  - OSが既にバッファリングしている場合：現代のOS