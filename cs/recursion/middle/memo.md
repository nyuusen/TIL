# 再帰

## 再帰の基本

- ある大きな問題を「同じ形のより小さな問題」に分解して、最終的に解けるサイズになるまで繰り返す
- ベースケースという再帰が止まる条件が必要

## スタック

### スタック

- データを一時的に積み上げるための構造
- LIFO(Last in, First out)
  - 書類を積み重ねるイメージ

### コールスタック

- プログラムが関数を呼び出した時に、その呼び出し履歴を記録しておくスタックのこと
- プログラムで関数が呼び出されると、OSはコールスタックという領域にパラメータや実行終了後に戻るべきコード内の場所などの関数に関する情報を格納する
- A()-> B()と呼ばれた場合は、B()が終了したらA()に戻ってみたいな

#### 再帰とコールスタック

- 再帰関数を呼び出すと、自分自身が再びスタックに積まれていく状態
- そしてベースケースでreturnされると、スタックが一段ずつpopされていく

## フィボナッチ数列

- フィボナッチ数列を木構造で表すと木の末端側から処理が徐々に実行される
  - ＋演算子より、関数実行が優先されるため、このような処理となる
  - フィボナッチ数列の再帰関数のコールスタックはLIFO
- このような処理を行うアルゴリズムを深さ優先探索（DFS: Depth First Search）という
  - よく引き合いに出される幅優先探索（BFS: Breadth First Search）は、逆にツリーの根本から

## 計算量

- 計算量とは「ある問題を解くのにどれくらい手間を要したかを数値で表したもの」
  - 時間計算量：手順の回数
  - 空間計算量：必要とする記憶領域（メモリ）
  - 同じ問題を解くにも、アルゴリズムが複数存在し、アルゴリズムの効率によって所要時間が大きく変わる
- 入力のサイズnに対して、アルゴリズムがどれくらいの時間がかかるか予測を立てるために、CSではO記法と呼ばれる記法を頻繁に使う（これを使って、実際に計算しなくても大まかに計算時間を測ることができる）
- O(log n)は「増えるけどゆっくり増える」
  - 線形 O(n) よりはるかに少ない回数で処理可能ということを表現できる

## 末尾再帰

- シンプルな総和を返す再帰関数では、n個の関数が順にコールスタックにpushされる
  - ただしコンピュータには物理制限があるため、nが大きくなるとスタックの保持上限を超えてスタックオーバーフローと言う現象が発生する
  - スタックオーバーフローは、ベースケースが機能しておらず、再帰関数が無限に呼び出されたり、空間計算量が大きいことが原因として考えられる
- スタックオーバーフローを回避する方法として、再帰関数を末尾関数(tail recursion)と呼ばれる特殊な形に書き換えると言うのがある
  - 末尾再帰は、再帰処理がすべての処理の最後に行われるもの（ex: `return f();`)
    - `return x + f();`は、関数呼び出しごに演算処理が実行されるため、再帰処理が関数最後の処理になっておらず、このタイプはヘッド再帰と呼ばれる
  - 末尾再帰は、呼び出し元の関数に戻る必要がないため、通常の再帰処理よりも速く実行される
- 末尾再帰を使うことによって、一部の言語では末尾呼び出し最適化（tail call optimization）という技術が適用されることがある
  - これは、再帰関数が呼び出された時に新しいスタックフレームを確保するのではなく、既存のスタックフレームの値が更新されるので、空間計算量を圧倒的に削減できるメリットがある
    - 関数は自信をpopし、次の関数を同じフレーム内にpushするので、空間計算量はO(1)になる
- 末尾再帰にすることで、自身をn回呼び出すだけでよくなるので、時間計算量がO(2のn乗)からO(n)に削減、空間計算量もO(n)からO(1)に削減できる

# スコープ

- ローカルスコープは、再帰で学習したコールスタックがポップされた時のことをイメージした通り、変数や引数は一時的なメモリに保存され、関数の処理が終了すると自動的に破棄される
- 一方、グローバルスコープに宣言された変数は、常にメモリ上に残る・占有する
  - バグの発生はもちろん、副作用の発生やメモリの無駄遣いにもつながってしまう
- すべての関数は個別のローカルスコープで実行される

## 副作用

- エラーには「文法エラー」と「論理エラー」がある
- 副作用とは「どこにある何かを、知らず知らずの内に変容させてしまっている」ことを意味する
- グローバル変数を使うと、意図しない副作用を引き起こすリスクが上がる
- ソフトウェア開発をする際は「副作用をなるべく引き起こさないこと」「必要最低限に留めること」を心がける

## 値渡しと参照渡し

- ある関数から、外部で定義された関数を呼び出すとスコープはどうなるか？
  - 呼び出された関数は、異なるローカルスコープを作成し、この時点で2つの親子関係を持たない別々のスコープが存在することになる
  - 関数の入力と出力によって、この並列な2つのスコープ間で値をやり取りできるようになる
- 仮引数と実引数
  - 仮引数(parameter):関数を定義するときに、外から値を受け取るための変数
  - 実引数(argument):関数を呼び出すときに実際に渡す値
- 仮引数にデータを渡す2つの方法
  - 値渡し
    - 実引数の値のコピーが、仮引数に渡される
    - メモリ上のセルに格納された変数のデータを、他のセルにコピーされる
    - 最近の全ての言語ではこの値渡しと呼ばれる方法で仮引数にデータを渡している
  - 参照渡し
    - 実引数のメモリアドレスが仮引数に渡される
    - つまり、2つの引数が同じメモリ上の場所を指すようになる（1つの引数に対して変更を加えると、もう一方にも変更が反映される）
  - 補足
    - Goは全て値渡しだが、スライス・マップ・ポインタは参照のように振る舞う（メモリアドレスのコピーを渡す＝アドレスを直接渡すわけではない）
      - なおスライスは要注意：[Go の Slice の落とし穴 #Go - Qiita](https://qiita.com/ktateish/items/1fdae8ac845da788a789)
    - JSはプリミティブは値渡し、オブジェクトは参照渡し
    - オブジェクトが参照渡しである言語が一定ある理由としては、メモリ効率（オブジェクトはサイズが大きい）・一貫したオブジェクト操作を提供する（どんなメソッドでも同じオブジェクトを共有できるOOPの整合性的な視点から）・そもそも関数内でオブジェクトを変更したケースが多い

## 静的、スタック、ヒープメモリ

- メモリ割り当ての3つの方法
  - 静的メモリ割り当て：
    - プログラムが実行される前であるコンパイル時に行われる
    - 割り当てサイズは固定で、プログラムの開始から終了まで変数は存続する
    - グローバル変数がこれ
  - スタックメモリ割り当て：
    - コンピュータが関数を呼び出す度に新しいメモリスペースを確保する
    - このスペースは、コールスタックと呼ばれる場所に一時的に保存され、関数で使用する変数のデータが格納される
    - スコープの終了とともに、変数とデータは削除され、スタック領域は削除される
    - 自動的に割り当てられるので、明示的に制御することはできないが、不要になったスペースは自動的に解放されるので、プログラムの実行を効率的に行うことができる
    - 関数呼び出し時にメモリが消費されるので永遠に関数を呼び続けることはできない。スタックの保持上限に達するとスタックオーバーフローが発生するという流れ。
    - 自動メモリ割り当て（automatic memory allocation）と呼ばれる
  - ヒープメモリ割り当て：
    - プログラムが明示的に割り当てることのできるメモリ領域
    - 動的メモリ割り当て （dynamic memory allocation） と呼ばれる
    - メモリを割り当てるには、newやmallocなどのキーワードをや関数が使用され、deleteやfreeなどの関数で解放する（メモリ有効期間はユーザーによって決定される）
      - Goの場合は`new(int)`
        - ただし、関数内でnewしたものを出力しない場合は、スタックに割り当てられる（この辺はGoは自動でやってくれる賢い）
        - あとは、関数でポインタを返したり、クロージャのキャプチャなどのケースでヒープに逃げる
      - ヒープのどこに置くかは、プログラム側ではなく、ランタイム(メモリアロケータ)が決める
    - スタックメモリのLIFOとは異なり、任意の順序でアクセスすることができる
      - スタックは一番上しかアクセスできない
    - ヒープメモリは隔離されている
      - なのでどのスコープからでも、アドレスを知っている限りアクセスできる
  - メモリリーク
    - ユーザーがヒープメモリの割り当てを削除し忘れて、そのメモリが2度と使われない状態を指す
    - メモリ性能低下の原因になるため注意が必要
  - ガベージコレクタ
    - CやC++のようにメモリを完全に制御できる言語ではメモリリークを回避する責任はユーザーにあるが、他のほとんどの言語ではインタプリタやコンパイラがその処理を行う
    - 使用しなくなったメモリをヒープメモリから自動的に削除する処理はガベージコレクタと呼ばれる
      - マークアンドスイープというアルゴリズムが使われる
    - ヒープメモリを自動で管理する言語では、手動で管理する機能がなく、全て自動で行われるので、データがスタックorヒープに保存されるだけを理解するだけでOK

# オブジェクト

- これまでは、原則として他のデータ型から構成されないプリミティブ型を中心に学習してきた
- プリミティブ型で表現するには限界があり、実世界には状態(state)と振る舞い(behavior)が存在する

## オブジェクトの状態

- クラス内のすべてのオブジェクトに対して共通する値はクラス変数として保存する
  - これは静的領域に保存される
- メンバ変数（インスタンス変数）として、オブジェクトが持つデータを状態を保存する
- thisやselfなどのキーワードで、現在のオブジェクトを参照するために

## 文字列とオブジェクト

- 文字列はプリミティブ型ではなくオブジェクトとして扱われる
- JavaScriptでは、プリミティブの文字列は自動的にStringオブジェクトに変換される
- 文字列は文字の配列として実装されていて、各文字や部分文字列に高速でアクセスすることを実現している
- 多くのプログラミング言語では、オブジェクト(String含む)を参照する変数は参照型と見なされる
  - 変数にはオブジェクトそのものが格納されているのではなく、メモリ位置への参照が格納される
  - 理由は、文字列オブジェクトが必要とするメモリの量を予測することは不可能であるため

### オブジェクト同士の比較

- オブジェクト同士の比較は参照に対して行われるので、同じ値を持っていてもfalseを返す