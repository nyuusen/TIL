# 再帰

## 再帰の基本

- ある大きな問題を「同じ形のより小さな問題」に分解して、最終的に解けるサイズになるまで繰り返す
- ベースケースという再帰が止まる条件が必要

## スタック

### スタック

- データを一時的に積み上げるための構造
- LIFO(Last in, First out)
  - 書類を積み重ねるイメージ

### コールスタック

- プログラムが関数を呼び出した時に、その呼び出し履歴を記録しておくスタックのこと
- プログラムで関数が呼び出されると、OSはコールスタックという領域にパラメータや実行終了後に戻るべきコード内の場所などの関数に関する情報を格納する
- A()-> B()と呼ばれた場合は、B()が終了したらA()に戻ってみたいな

#### 再帰とコールスタック

- 再帰関数を呼び出すと、自分自身が再びスタックに積まれていく状態
- そしてベースケースでreturnされると、スタックが一段ずつpopされていく

## フィボナッチ数列

- フィボナッチ数列を木構造で表すと木の末端側から処理が徐々に実行される
  - ＋演算子より、関数実行が優先されるため、このような処理となる
  - フィボナッチ数列の再帰関数のコールスタックはLIFO
- このような処理を行うアルゴリズムを深さ優先探索（DFS: Depth First Search）という
  - よく引き合いに出される幅優先探索（BFS: Breadth First Search）は、逆にツリーの根本から

## 計算量

- 計算量とは「ある問題を解くのにどれくらい手間を要したかを数値で表したもの」
  - 時間計算量：手順の回数
  - 空間計算量：必要とする記憶領域（メモリ）
  - 同じ問題を解くにも、アルゴリズムが複数存在し、アルゴリズムの効率によって所要時間が大きく変わる
- 入力のサイズnに対して、アルゴリズムがどれくらいの時間がかかるか予測を立てるために、CSではO記法と呼ばれる記法を頻繁に使う（これを使って、実際に計算しなくても大まかに計算時間を測ることができる）
- O(log n)は「増えるけどゆっくり増える」
  - 線形 O(n) よりはるかに少ない回数で処理可能ということを表現できる

## 末尾再帰

- シンプルな総和を返す再帰関数では、n個の関数が順にコールスタックにpushされる
  - ただしコンピュータには物理制限があるため、nが大きくなるとスタックの保持上限を超えてスタックオーバーフローと言う現象が発生する
  - スタックオーバーフローは、ベースケースが機能しておらず、再帰関数が無限に呼び出されたり、空間計算量が大きいことが原因として考えられる
- スタックオーバーフローを回避する方法として、再帰関数を末尾関数(tail recursion)と呼ばれる特殊な形に書き換えると言うのがある