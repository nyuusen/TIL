# 再帰

## 再帰の基本

- ある大きな問題を「同じ形のより小さな問題」に分解して、最終的に解けるサイズになるまで繰り返す
- ベースケースという再帰が止まる条件が必要

## スタック

### スタック

- データを一時的に積み上げるための構造
- LIFO(Last in, First out)
  - 書類を積み重ねるイメージ

### コールスタック

- プログラムが関数を呼び出した時に、その呼び出し履歴を記録しておくスタックのこと
- プログラムで関数が呼び出されると、OSはコールスタックという領域にパラメータや実行終了後に戻るべきコード内の場所などの関数に関する情報を格納する
- A()-> B()と呼ばれた場合は、B()が終了したらA()に戻ってみたいな

#### 再帰とコールスタック

- 再帰関数を呼び出すと、自分自身が再びスタックに積まれていく状態
- そしてベースケースでreturnされると、スタックが一段ずつpopされていく

## フィボナッチ数列

- フィボナッチ数列を木構造で表すと木の末端側から処理が徐々に実行される
  - ＋演算子より、関数実行が優先されるため、このような処理となる
  - フィボナッチ数列の再帰関数のコールスタックはLIFO
- このような処理を行うアルゴリズムを深さ優先探索（DFS: Depth First Search）という
  - よく引き合いに出される幅優先探索（BFS: Breadth First Search）は、逆にツリーの根本から

## 計算量

- 計算量とは「ある問題を解くのにどれくらい手間を要したかを数値で表したもの」
  - 時間計算量：手順の回数
  - 空間計算量：必要とする記憶領域（メモリ）
  - 同じ問題を解くにも、アルゴリズムが複数存在し、アルゴリズムの効率によって所要時間が大きく変わる
- 入力のサイズnに対して、アルゴリズムがどれくらいの時間がかかるか予測を立てるために、CSではO記法と呼ばれる記法を頻繁に使う（これを使って、実際に計算しなくても大まかに計算時間を測ることができる）
- O(log n)は「増えるけどゆっくり増える」
  - 線形 O(n) よりはるかに少ない回数で処理可能ということを表現できる

## 末尾再帰

- シンプルな総和を返す再帰関数では、n個の関数が順にコールスタックにpushされる
  - ただしコンピュータには物理制限があるため、nが大きくなるとスタックの保持上限を超えてスタックオーバーフローと言う現象が発生する
  - スタックオーバーフローは、ベースケースが機能しておらず、再帰関数が無限に呼び出されたり、空間計算量が大きいことが原因として考えられる
- スタックオーバーフローを回避する方法として、再帰関数を末尾関数(tail recursion)と呼ばれる特殊な形に書き換えると言うのがある
  - 末尾再帰は、再帰処理がすべての処理の最後に行われるもの（ex: `return f();`)
    - `return x + f();`は、関数呼び出しごに演算処理が実行されるため、再帰処理が関数最後の処理になっておらず、このタイプはヘッド再帰と呼ばれる
  - 末尾再帰は、呼び出し元の関数に戻る必要がないため、通常の再帰処理よりも速く実行される
- 末尾再帰を使うことによって、一部の言語では末尾呼び出し最適化（tail call optimization）という技術が適用されることがある
  - これは、再帰関数が呼び出された時に新しいスタックフレームを確保するのではなく、既存のスタックフレームの値が更新されるので、空間計算量を圧倒的に削減できるメリットがある
    - 関数は自信をpopし、次の関数を同じフレーム内にpushするので、空間計算量はO(1)になる
- 末尾再帰にすることで、自身をn回呼び出すだけでよくなるので、時間計算量がO(2のn乗)からO(n)に削減、空間計算量もO(n)からO(1)に削減できる

# スコープ

- ローカルスコープは、再帰で学習したコールスタックがポップされた時のことをイメージした通り、変数や引数は一時的なメモリに保存され、関数の処理が終了すると自動的に破棄される
- 一方、グローバルスコープに宣言された変数は、常にメモリ上に残る・占有する
  - バグの発生はもちろん、副作用の発生やメモリの無駄遣いにもつながってしまう
- すべての関数は個別のローカルスコープで実行される

## 副作用

- エラーには「文法エラー」と「論理エラー」がある
- 副作用とは「どこにある何かを、知らず知らずの内に変容させてしまっている」ことを意味する
- グローバル変数を使うと、意図しない副作用を引き起こすリスクが上がる
- ソフトウェア開発をする際は「副作用をなるべく引き起こさないこと」「必要最低限に留めること」を心がける

## 値渡しと参照渡し

- ある関数から、外部で定義された関数を呼び出すとスコープはどうなるか？
  - 呼び出された関数は、異なるローカルスコープを作成し、この時点で2つの親子関係を持たない別々のスコープが存在することになる＝