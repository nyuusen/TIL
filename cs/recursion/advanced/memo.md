# データ構造入門

## 連結リスト

- 連結リストはメモリ上の連続したブロックに格納されないデータ構造
  - 配列は連続したメモリに格納される
- 代わりに、データはポインタによって接続された一連のシーケンスで構成される
- 各要素はノードと呼ばれ、各ノードにはデータと次のノードへの参照（ポインタ）が格納される
  - あるノードから次のノードへの移動にはこのポインタをたどるので、データ要素を順番に辿ることでリスト全体を走査できる

### 片方向リスト

- 連結リストの中で、最も基本的な形態
- dataとnextという変数から構成される
  - nextは次のノードオブジェクトの参照（メモリアドレス）が格納されるのでポインタと呼ばれる
  - 最後尾のnextはnull値が格納される
- インデックス効率は悪い
  - 最悪の場合、O(n)かかる
- 挿入
  - 配列がサイズ固定であることに対し、連結リストはサイズを柔軟に変更可能

### 双方向リスト

- 連結リストの1つで双方向の走査を可能にするもの
- 双方向リストのデータ構造
  - リストヘッダー：headポインタ、tailポインタ（先頭と末尾）
  - ノード：データ、prevポインタ、nextポインタ
- 双方向リストは、各ノードに次のノードへの単一のポインタだけでなく、前のノードへのポインタも含んでいるため、順方向・逆方向の両方で走査が可能
- 片方向リストと大きく異なる点は、要素の削除がO(1)で実行可能
  - ABCという要素があり、Bを削除する場合は、AのnextとCのprevを削除するだけ

## スタック

- スタックはLIFOの原則に従った線形データ構造で、スタックに追加された最初の要素が最初に削除される要素と一致する
- スタックは配列や連結リストを使用して実装される
- 一般的な用途の1つは、プログラミング言語における関数呼び出しの実装
  - 関数が呼び出されると、その引数とローカル変数がスタックにプッシュされ、関数が戻るとこれらの値がスタックからポップされる
- 最後に入れたものが最初に出てくるようなデータの保管方法なので、ゲームやアプリの「元に戻す」ボタンが良い例となる

## キュー

- キューは、FIFOの原則に従った線形データ構造
- キューには以下の操作がある
  - Enqueue: キューの末尾に新しい要素を追加する
  - Dequeue: キューの先頭の要素を削除し、その要素を返す

### 両端キュー

- 両端からデータを追加・削除できるようになったキュー
- DequeueBack(リストの末尾にある要素を削除して返す関数)は片方向リストだと時間計算量がO(n)になってしまうので、末尾にprevを使って効率よくアクセスするために**双方向リストを使用する**

## 木構造

- グラフ理論において、個々の要素は頂点またはノード、2つの要素間の関係は辺と呼ばれる
- グラフの中には以下の2種類がある
  - 閉路：1つの頂点から出発して、同じ頂点に戻ってくるような辺
  - 木構造：閉路が1つもない、つまり1つの道を進むと戻ってくることがないような形状
    - 木構造は、1つの親から複数の子が分岐していくような親とこの関係を表すのにとても役立つ
- それぞれの親が最大2つの子を持つ特殊な木構造を二分木（バイナリツリー）という
  - この二分木を使って、コンピュータ計算に不可欠な操作の「ソート」と「検索」を効率的に処理することができる
- 用語整理
  - 葉ノード（leaf node）：ノードに子がないもの
  - 高さ：あるノードから葉ノードへの辺の数の最大値
  - 深さ：あるノードから根ノードまでのへんの数

### 二分木(Binary Tree)

- あるノードが持つ子の数が最大2であるデータ構造
- 探索する時間がデータ数の対数(log n)になるため、大量のデータを効率的に探索できる
  - 例えば二分探索木（BST:Binary Search Tree）などのように、二分木が特定の順序で構成されている場合、探索する際に次に見るべきノードが左の子か右の子かをそのノードの値と比較することが決定できる
  - これにより、それぞれの探索ステップで探索範囲が半分になるため、探索時間がデータの数の対数（log n）になる
- 二分木のバリエーションはいくつかある
  - 全二分木：ノードが子を2つ持つか持たないかのどちらか（1つだけ子を持つノードは存在しない）
  - 完全二分木：全ての葉ノードが同じ深さを持つ二分木
  - 二分探索木：木の各ノードが左の子孫の値<=親の値<=右の子孫の値という制約を持つ二分木

### 二分探索木

- 二分探索木の探索効率が最もよくなるのは「木の高さが最も低い」ケース
  - バランスとれていない木＝例えばn個のノードを持ち、n-1の高さを持つ極端なケースで考えると、性能はO(n)となる
- 根ノードから各葉までの高さができるだけ等しくなった状態のものは「平衡二分探索木」と呼び、探索効率が最も良く計算量はO(log n)となる
- ソート済みのリストから平衡二分探索木を作る方法
  - 中央の値を根ノードにする
  - それより左側の値を使って、左の部分木を作る
  - 右側の値を使って、右の部分木を作る
  - これを再起的に行う

## 木構造の走査（traverse）

- 走査（traverse）とは、木の各ノードを1回ずつ特定の規則に従って見て回ることを意味する
  - これは人が公園の全ての木を見て回るようなイメージで、順番に全てのノードを訪れるため、n個のノードがある場合はn回の操作が必要になり、時間計算量はO(n)となる
- 線形のデータ構造＝連携リストや一次元配列のような要素が一列に並んでいるようなデータは、最初の要素から順に見ていくことが一般的（本棚に並んでいる本を左から右に順番に探していくようなイメージ）

### 深さ優先探索（depth-first search:DFS）

- 木構造の探索（走査）アルゴリズム
- 行けるところまで深く突き進み、行き止まりになったら一歩戻って別の道を探すという戦略
- 実装方法としては再帰を使用し、関数呼び出し自体が「コールスタック」を利用するため、自然と深さ優先となる
- 特徴
  - 木が深くて、答えが浅い場所にある場合は非効率
  - メモリ消費（スタックの深さ）は木の高さに比例するため、BFSより少なく済むことが多い
  - 全てのパターンを網羅したい、迷路の解法、末端（葉）の情報を集約したい用途に向いている
- 例題として、根ノードと整数(targetSum)が与えられるので、根から葉までの経路の中に、ノードの値を合計するとtargetSumになる経路があるかどうかを判定する
  - これは、とりあえず各経路一番深いところまで探索する必要があるのでDFSが有効である
  - 実装としては、自分の値が9でtargetSumが15である場合、残りは6となるので、その子たちに「合計6となる経路ってある？」というのを再帰的に繰り返していくイメージ
- 他に有効なパターンとしては、
  - JSONのキーを全てスキャンする
    - JSONはオブジェクトの中にオブジェクトを格納できるデータ構造
    - 今見ているキーが単純な値なら何らかの処理、オブジェクトなら再帰的に再度関数を呼び出すことを繰り返し行う
  - 複雑な承認フローで権限があるかをチェックする
    - ユーザーが、ある文書を編集できるか？を判定するロジックを作るとする
    - ユーザーAはグループBに所属していて、グループBは部署Cを継承していて..みたいなケース
    - まずは1つのルートを一番奥（継承元）まで進み、そこで権限が見つかればtrueを返す、見つからなければ一歩戻って別のルートを再帰的に..

### 幅優先探索（depth-first search:BFS）

- 出発点から近い順に広く、層ごとに探索を進める戦略
- 最も近いサーバーを探すネットワークや最短ルートを探す地図アプリに向いている
- あとはデータが無限に深く続いている可能性がある場合、DFSだと帰ってこれなくなるので、BFSなら浅い所から順に見つけられる
- 例えば、二分木の根ノードから与えられるので、根から最も近いはノードまでの最短経路にあるノードを返す問題
  - 根ノードを距離1とし、そこから隣接する子ノードへ1段ずつ一斉に進む
  - 浅い段から順に調べているので最初に見つけた葉が最短と判断できる
  - 実装としてはキューに、次に調べる人の行列を作る
- 他に有効なパターンとしては、
  - 「最短」というキーワードが出た時
  - 階層ごとにまとめたい時（例えば組織図から1階層目、2階層目など階層（役職）ごとにリストを作りたい）

### BST「挿入」「削除」

- 挿入（比較的単純）
  - ルートから開始し、挿入したい値と現在のノードを比較し、左右で比較。値が小さければ左へ、大きければ右へ進む
  - 進んだ先がnullだったら、そこに新しいノードを配置する
  - 計算量は、バランスが取れていればO(log n)となり、最悪の場合はただのリストとなりO(n)となる
- 削除（複雑）
  - 子がいないリーフノードの場合
    - そのノードをそのまま削除するだけ
  - 子が1人の場合
    - 削除するノードの親と子を直接繋ぐ（子を昇格させる）
  - 子が2人の場合
    - 削除するノードの場所に、その値に最も近い値を持ってきて、木の構造を維持する
      - 具体的には、右部分木の最小値を削除対象のノードにコピーし、コピー元のノードを削除する
      - 右部分木の最小値を削除対象の後継にすることで、BSTのルール（左の子＜親＜右の子」というルールを崩さずに削除することができる

### 二分ヒープ

- 常に最大値もしくは最小値を高速に取り出すことに特化した完全二分木の形をしたデータ構造
  - B+treeやBSTがどこに何があるかを整理するためのものなら、二分ヒープは「誰が一番優先順位が高いか」を管理するためのもの
- 二分ヒープが成立するための条件
  - 親子の大小関係
    - 最大ヒープ：根ノードが最大値であること
    - 最小ヒープ：根ノードが最小値であること
  - 完全二分木であること
    - 完全二分木（全てのリーフからルートまでが同じ深さであり、リーフ以外の内部ノードが全ての2つの子ノードを持つ）であることで、配列で効率的に表現できる
    - 完全二分木＝ノード間に隙間がないので、配列インデックスと1帯1
- ソフトウェア開発における使い所
  - 優先度付きキュー
    - 各プログラミング言語の標準ライブラリにある優先度付きキューはほぼ間違いなく二分ヒープ
    - ダイクストラ
      - カーナビなどの経路探索
    - ヒープソート
      - 二分ヒープの構造を利用したソートアルゴリズムで、追加のメモリをほとんど使わず
- BSTとの違い
  - BSTは、左＜親＜右なので、木が偏る可能性がある
  - 二分ヒープは、優先順位用で、常に完全二分木で形が崩れない