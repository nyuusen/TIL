# データ構造入門

## 連結リスト

- 連結リストはメモリ上の連続したブロックに格納されないデータ構造
  - 配列は連続したメモリに格納される
- 代わりに、データはポインタによって接続された一連のシーケンスで構成される
- 各要素はノードと呼ばれ、各ノードにはデータと次のノードへの参照（ポインタ）が格納される
  - あるノードから次のノードへの移動にはこのポインタをたどるので、データ要素を順番に辿ることでリスト全体を走査できる

### 片方向リスト

- 連結リストの中で、最も基本的な形態
- dataとnextという変数から構成される
  - nextは次のノードオブジェクトの参照（メモリアドレス）が格納されるのでポインタと呼ばれる
  - 最後尾のnextはnull値が格納される
- インデックス効率は悪い
  - 最悪の場合、O(n)かかる
- 挿入
  - 配列がサイズ固定であることに対し、連結リストはサイズを柔軟に変更可能

### 双方向リスト

- 連結リストの1つで双方向の走査を可能にするもの
- 双方向リストは、各ノードに次のノードへの単一のポインタだけでなく、前のノードへのポインタも含んでいるため、順方向・逆方向の両方で走査が可能
- 片方向リストと大きく異なる点は、要素の削除がO(1)で実行可能
  - ABCという要素があり、Bを削除する場合は、AのnextとCのprevを削除するだけ

## スタック

- スタックはLIFOの原則に従った線形データ構造で、スタックに追加された最初の要素が最初に削除される要素と一致する
- スタックは配列や連結リストを使用して実装される
- 一般的な用途の1つは、プログラミング言語における関数呼び出しの実装
  - 関数が呼び出されると、その引数とローカル変数がスタックにプッシュされ、関数が戻るとこれらの値がスタックからポップされる
- 最後に入れたものが最初に出てくるようなデータの保管方法なので、ゲームやアプリの「元に戻す」ボタンが良い例となる

## キュー

- キューは、FIFOの原則に従った線形データ構造
- キューには以下の操作がある
  - Enqueue: キューの末尾に新しい要素を追加する
  - Dequeue: キューの先頭の要素を削除し、その要素を返す

### 両端キュー

- 両端からデータを追加・削除できるようになったキュー
