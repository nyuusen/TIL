# データ構造入門

## 連結リスト

- 連結リストはメモリ上の連続したブロックに格納されないデータ構造
  - 配列は連続したメモリに格納される
- 代わりに、データはポインタによって接続された一連のシーケンスで構成される
- 各要素はノードと呼ばれ、各ノードにはデータと次のノードへの参照（ポインタ）が格納される
  - あるノードから次のノードへの移動にはこのポインタをたどるので、データ要素を順番に辿ることでリスト全体を走査できる

### 片方向リスト

- 連結リストの中で、最も基本的な形態
- dataとnextという変数から構成される
  - nextは次のノードオブジェクトの参照（メモリアドレス）が格納されるのでポインタと呼ばれる
  - 最後尾のnextはnull値が格納される
- インデックス効率は悪い
  - 最悪の場合、O(n)かかる
- 挿入
  - 配列がサイズ固定であることに対し、連結リストはサイズを柔軟に変更可能

### 双方向リスト

- 連結リストの1つで双方向の走査を可能にするもの
- 双方向リストのデータ構造
  - リストヘッダー：headポインタ、tailポインタ（先頭と末尾）
  - ノード：データ、prevポインタ、nextポインタ
- 双方向リストは、各ノードに次のノードへの単一のポインタだけでなく、前のノードへのポインタも含んでいるため、順方向・逆方向の両方で走査が可能
- 片方向リストと大きく異なる点は、要素の削除がO(1)で実行可能
  - ABCという要素があり、Bを削除する場合は、AのnextとCのprevを削除するだけ

## スタック

- スタックはLIFOの原則に従った線形データ構造で、スタックに追加された最初の要素が最初に削除される要素と一致する
- スタックは配列や連結リストを使用して実装される
- 一般的な用途の1つは、プログラミング言語における関数呼び出しの実装
  - 関数が呼び出されると、その引数とローカル変数がスタックにプッシュされ、関数が戻るとこれらの値がスタックからポップされる
- 最後に入れたものが最初に出てくるようなデータの保管方法なので、ゲームやアプリの「元に戻す」ボタンが良い例となる

## キュー

- キューは、FIFOの原則に従った線形データ構造
- キューには以下の操作がある
  - Enqueue: キューの末尾に新しい要素を追加する
  - Dequeue: キューの先頭の要素を削除し、その要素を返す

### 両端キュー

- 両端からデータを追加・削除できるようになったキュー
- DequeueBack(リストの末尾にある要素を削除して返す関数)は片方向リストだと時間計算量がO(n)になってしまうので、末尾にprevを使って効率よくアクセスするために**双方向リストを使用する**

## 木構造

- グラフ理論において、個々の要素は頂点またはノード、2つの要素間の関係は辺と呼ばれる
- グラフの中には以下の2種類がある
  - 閉路：1つの頂点から出発して、同じ頂点に戻ってくるような辺
  - 木構造：閉路が1つもない、つまり1つの道を進むと戻ってくることがないような形状
    - 木構造は、1つの親から複数の子が分岐していくような親とこの関係を表すのにとても役立つ
- それぞれの親が最大2つの子を持つ特殊な木構造を二分木（バイナリツリー）という
  - この二分木を使って、コンピュータ計算に不可欠な操作の「ソート」と「検索」を効率的に処理することができる
- 用語整理
  - 葉ノード（leaf node）：ノードに子がないもの
  - 高さ：あるノードから葉ノードへの辺の数の最大値
  - 深さ：あるノードから根ノードまでのへんの数

### 二分木(Binary Tree)

- あるノードが持つ子の数が最大2であるデータ構造
- 探索する時間がデータ数の対数(log n)になるため、大量のデータを効率的に探索できる
  - 例えば二分探索木（BST:Binary Search Tree）などのように、二分木が特定の順序で構成されている場合、探索する際に次に見るべきノードが左の子か右の子かをそのノードの値と比較することが決定できる
  - これにより、それぞれの探索ステップで探索範囲が半分になるため、探索時間がデータの数の対数（log n）になる
- 二分木のバリエーションはいくつかある
  - 全二分木：ノードが子を2つ持つか持たないかのどちらか（1つだけ子を持つノードは存在しない）
  - 完全二分木：全ての葉ノードが同じ深さを持つ二分木
  - 二分探索木：木の各ノードが左の子孫の値<=親の値<=右の子孫の値という制約を持つ二分木

### 二分探索木

- 二分探索木の探索効率が最もよくなるのは「木の高さが最も低い」ケース
  - バランスとれていない木＝例えばn個のノードを持ち、n-1の高さを持つ極端なケースで考えると、性能はO(n)となる
- 根ノードから各葉までの高さができるだけ等しくなった状態のものは「平衡二分探索木」と呼び、探索効率が最も良く計算量はO(log n)となる
- ソート済みのリストから平衡二分探索木を作る方法
  - 中央の値を根ノードにする
  - それより左側の値を使って、左の部分木を作る
  - 右側の値を使って、右の部分木を作る
  - これを再起的に行う

## 木構造の走査（traverse）

- 走査（traverse）とは、木の各ノードを1回ずつ特定の規則に従って見て回ることを意味する
  - これは人が公園の全ての木を見て回るようなイメージで、順番に全てのノードを訪れるため、n個のノードがある場合はn回の操作が必要になり、時間計算量はO(n)となる
- 線形のデータ構造＝連携リストや一次元配列のような要素が一列に並んでいるようなデータは、最初の要素から順に見ていくことが一般的（本棚に並んでいる本を左から右に順番に探していくようなイメージ）

### 深さ優先探索（depth-first search:DFS）

- 木構造の探索（走査）アルゴリズム
- 行けるところまで深く突き進み、行き止まりになったら一歩戻って別の道を探すという戦略
- 実装方法としては再帰を使用し、関数呼び出し自体が「コールスタック」を利用するため、自然と深さ優先となる
- 特徴
  - 木が深くて、答えが浅い場所にある場合は非効率
  - メモリ消費（スタックの深さ）は木の高さに比例するため、BFSより少なく済むことが多い
  - 全てのパターンを網羅したい、迷路の解法、末端（葉）の情報を集約したい用途に向いている
- 例題として、根ノードと整数(targetSum)が与えられるので、根から葉までの経路の中に、ノードの値を合計するとtargetSumになる経路があるかどうかを判定する
  - これは、とりあえず各経路一番深いところまで探索する必要があるのでDFSが有効である
  - 実装としては、自分の値が9でtargetSumが15である場合、残りは6となるので、その子たちに「合計6となる経路ってある？」というのを再帰的に繰り返していくイメージ
- 他に有効なパターンとしては、
  - JSONのキーを全てスキャンする
    - JSONはオブジェクトの中にオブジェクトを格納できるデータ構造
    - 今見ているキーが単純な値なら何らかの処理、オブジェクトなら再帰的に再度関数を呼び出すことを繰り返し行う
  - 複雑な承認フローで権限があるかをチェックする
    - ユーザーが、ある文書を編集できるか？を判定するロジックを作るとする
    - ユーザーAはグループBに所属していて、グループBは部署Cを継承していて..みたいなケース
    - まずは1つのルートを一番奥（継承元）まで進み、そこで権限が見つかればtrueを返す、見つからなければ一歩戻って別のルートを再帰的に..

### 幅優先探索（depth-first search:BFS）

- 出発点から近い順に広く、層ごとに探索を進める戦略
- 最も近いサーバーを探すネットワークや最短ルートを探す地図アプリに向いている
- あとはデータが無限に深く続いている可能性がある場合、DFSだと帰ってこれなくなるので、BFSなら浅い所から順に見つけられる
- 例えば、二分木の根ノードから与えられるので、根から最も近いはノードまでの最短経路にあるノードを返す問題
  - 根ノードを距離1とし、そこから隣接する子ノードへ1段ずつ一斉に進む
  - 浅い段から順に調べているので最初に見つけた葉が最短と判断できる
  - 実装としてはキューに、次に調べる人の行列を作る
- 他に有効なパターンとしては、
  - 「最短」というキーワードが出た時
  - 階層ごとにまとめたい時（例えば組織図から1階層目、2階層目など階層（役職）ごとにリストを作りたい）

### BST「挿入」「削除」

- 挿入（比較的単純）
  - ルートから開始し、挿入したい値と現在のノードを比較し、左右で比較。値が小さければ左へ、大きければ右へ進む
  - 進んだ先がnullだったら、そこに新しいノードを配置する
  - 計算量は、バランスが取れていればO(log n)となり、最悪の場合はただのリストとなりO(n)となる
- 削除（複雑）
  - 子がいないリーフノードの場合
    - そのノードをそのまま削除するだけ
  - 子が1人の場合
    - 削除するノードの親と子を直接繋ぐ（子を昇格させる）
  - 子が2人の場合
    - 削除するノードの場所に、その値に最も近い値を持ってきて、木の構造を維持する
      - 具体的には、右部分木の最小値を削除対象のノードにコピーし、コピー元のノードを削除する
      - 右部分木の最小値を削除対象の後継にすることで、BSTのルール（左の子＜親＜右の子」というルールを崩さずに削除することができる

### 二分ヒープ

- 常に最大値もしくは最小値を高速に取り出すことに特化した完全二分木の形をしたデータ構造
  - B+treeやBSTがどこに何があるかを整理するためのものなら、二分ヒープは「誰が一番優先順位が高いか」を管理するためのもの
- 二分ヒープが成立するための条件
  - 親子の大小関係
    - 最大ヒープ：根ノードが最大値であること
    - 最小ヒープ：根ノードが最小値であること
  - 完全二分木であること
    - 完全二分木（全てのリーフからルートまでが同じ深さであり、リーフ以外の内部ノードが全ての2つの子ノードを持つ）であることで、配列で効率的に表現できる
    - 完全二分木＝ノード間に隙間がないので、配列インデックスと1帯1
- ソフトウェア開発における使い所
  - 優先度付きキュー
    - 各プログラミング言語の標準ライブラリにある優先度付きキューはほぼ間違いなく二分ヒープ
    - ダイクストラ
      - カーナビなどの経路探索
    - ヒープソート
      - 二分ヒープの構造を利用したソートアルゴリズムで、追加のメモリをほとんど使わず
- 通常の木構造（BST）との違い
  - 通常の木構造は各ノードがLeftやRightというポインタを保持する
    - 二分ヒープはポインタを保存せずデータそのものを並べるため、メモリ消費を大幅に抑えられる
  - ポインタ形式だと各ノードがあちこちに散らばりランダムアクセスとなるが、配列形式だとメモリの連続した区画に並んでいるのでシーケンシャルアクセスとなり、CPUキャッシュヒット率が向上する（CPUはメモリを読む際、その周辺のデータもまとめてキャッシュに読み込む）
  - BSTは、左＜親＜右なので、木が偏る可能性がある
  - 二分ヒープは、優先順位用で、常に完全二分木で形が崩れない

#### Max-Heapify

- 最大ヒープ（親が最大値）のデータ構造を維持するための関数
  - ある特定のノードを起点とし、左右の子のノードと比較し、必要であればスワップを行う
- 計算量はO(log n)となる

#### ヒープソート

- 二分ヒープのデータ構造を用いてソート（並び替え）を行うアルゴリズム
  ```
  最大値の確定: 根にある最大値（配列の[0]番目）を、未整理エリアの「最後尾」と入れ替えます。

  エリアの縮小: 最後尾に置いた最大値は「整列済み」として、次からは無視します。

  再ヒープ化: 根に持ってきた新しい値を、正しい位置まで沈めます（Down Heap）。これにより、次に大きい値が再び根に浮上します。

  これを全ての要素が整列されるまで繰り返します。
  ```
- ヒープソートの特徴
  - 追加メモリがほぼゼロ（in-place）
    - 配列の中で要素を入れ替えるだけなので新しい配列を作る必要がない
  - 最悪の場合でも速度が落ちない
    - クイックソートはデータの並び順によってはO(nの2乗)に劣化する弱点があるが、ヒープソートはどんなにバラバラなデータでも常にO(n log n)を維持する

# ラムダ関数

- 無名・匿名関数とも言われる
  - 通常の関数のように名前で縛られず、関数リテラルとしてその場で作成される関数なので「無名・匿名」
- 通常の関数におけるメモリのセグメント
  - ①コードセグメント
    - 読み取り専用で、実行可能なプログラム（命令）のコードが格納される
    - これらの命令は、プロセッサによって直接解釈・実行される
  - ②データセグメント
    - グローバル変数や静的変数が格納される
    - これらの変数はプログラムが実行されている間ずっと存在する
  - ③ヒープセグメント
    - 動的にメモリを確保するための領域
    - プログラム実行中に要求される時にメモリが割り当てられ、不要になると解放される
  - ④スタックセグメント
    - 関数の呼び出しとそれに伴い局所変数の保存に使用される
    - 関数が呼び出されると新たなスタックフレームが作られ、関数が終了するとそのフレームは破棄される
    - プログラムによって自動で管理される
- ラムダ関数
  - JSでは変数にバインド（割り当て）が可能
  - メモリ上でオブジェクトとして扱われ、ヒープ領域に格納される
  - オブジェクトなので、他のデータと同じように扱うことができ、関数に渡したり、関数から返したり、変数に格納することが可能
  - 関数がどこにあるかを指し示す参照情報がプログラムから消え、その関数への参照がなくなると、もはや使用されていないとみなされ、ガベージコレクションの対象となる

# 高階関数

- 変数に格納され、入力として渡され、出力として返されるデータ型は第一級オブジェクトと呼ばれる
  - これはその言語の他のデータと同様に扱うことができ、その言語が提供する基本的な操作や関数を実行できることを意味する
  - 関数をデータのように扱える言語は、第一級関数を持つと言われる
- 呼び出し可能なオブジェクトはデータのように扱うことができ、関数を入力として受け取り、関数を出力として返す関数を「高階関数」という
- 